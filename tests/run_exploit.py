#!/usr/bin/env python3
"""
Houdinis Framework - Exploit Runner
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
License: MIT

Command-line interface for running individual Houdinis modules
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

import importlib.util
import argparse
from pathlib import Path


class ExploitRunner:
    """Runner for Houdinis exploit modules"""

    def __init__(self):
        """TODO: Add description for __init__"""
        self.available_exploits = {
            'rsa_shor': {
                'path': 'exploits/rsa_shor.py',
                'description': 'RSA factorization using Shor\'s algorithm',
                'usage': 'rsa_shor <target_number> [backend_type]'
            },
            'dh_shor': {
                'path': 'exploits/dh_shor.py',
                'description': 'Diffie-Hellman discrete log attack',
                'usage': 'dh_shor <generator> <public_key> <prime>'
            },
            'grover_bruteforce': {
                'path': 'exploits/grover_bruteforce.py',
                'description': 'Grover\'s algorithm brute force attack',
                'usage': 'grover_bruteforce <target_hash> [hash_type] [max_length]'
            },
            'ecdsa_vuln_scanner': {
                'path': 'exploits/ecdsa_vuln_scanner.py',
                'description': 'ECDSA quantum vulnerability scanner',
                'usage': 'ecdsa_vuln_scanner <target_host1> [target_host2] ... [--port PORT]'
            },
            'aes_assessment': {
                'path': 'exploits/aes_assessment.py',
                'description': 'AES quantum vulnerability assessment',
                'usage': 'aes_assessment <comprehensive|single> [key_size] [mode]'
            },
            'tls_sndl': {
                'path': 'exploits/tls_sndl.py',
                'description': 'TLS Store Now Decrypt Later attack',
                'usage': 'tls_sndl <target_host1> [target_host2] ... [--port PORT]'
            },
            'quantum_rng': {
                'path': 'exploits/quantum_rng.py',
                'description': 'Quantum Random Number Generator',
                'usage': 'quantum_rng <bits|key|benchmark> [options]'
            },
            'ssh_quantum_attack': {
                'path': 'exploits/ssh_quantum_attack.py',
                'description': 'SSH quantum vulnerability assessment',
                'usage': 'ssh_quantum_attack <target_host1> [target_host2] ... [--port PORT]'
            },
            'bitcoin_key_recovery': {
                'path': 'exploits/bitcoin_key_recovery.py',
                'description': 'Bitcoin quantum key recovery analysis',
                'usage': 'bitcoin_key_recovery <address1> [address2] ... [--file addresses.txt]'
            },
            'pgp_quantum_crack': {
                'path': 'exploits/pgp_quantum_crack.py',
                'description': 'PGP/GPG quantum vulnerability analysis',
                'usage': 'pgp_quantum_crack <key_file1> [key_file2] ... [--output report.txt]'
            },
            'ipsec_quantum_vuln': {
                'path': 'exploits/ipsec_quantum_vuln.py',
                'description': 'IPSec quantum vulnerability scanner',
                'usage': 'ipsec_quantum_vuln <target1> [target2] ... [--config config.conf]'
            },
            'ike_quantum_attack': {
                'path': 'exploits/ike_quantum_attack.py',
                'description': 'IKE quantum attack and security assessment',
                'usage': 'ike_quantum_attack <target1> [target2] ... [--ports 500 4500]'
            },
            'pq_migration_tools': {
                'path': 'exploits/pq_migration_tools.py',
                'description': 'Post-quantum migration assessment tools',
                'usage': 'pq_migration_tools <directory> [--output report.txt] [--format json]'
            },
            'quantum_network_recon': {
                'path': 'exploits/quantum_network_recon.py',
                'description': 'Quantum-focused network reconnaissance',
                'usage': 'quantum_network_recon <network1> [network2] ... [--output report.txt]'
            }
        }

    def list_exploits(self):
        """List all available exploits"""
        print(" Houdinis Framework - Available Exploits")
        print("=" * 60)

        for name, info in self.available_exploits.items():
            print(f"\n {name}")
            print(f"   Description: {info['description']}")
            print(f"   Usage: {info['usage']}")

        print(f"\n Run exploit: python run_exploit.py <exploit_name> [args...]")
        print(f" Example: python run_exploit.py rsa_shor 15")

    def run_exploit(self, exploit_name: str, args: list):
        """Run a specific exploit"""
        if exploit_name not in self.available_exploits:
            print(f" Unknown exploit: {exploit_name}")
            print(f"Available exploits: {', '.join(self.available_exploits.keys())}")
            return False

        exploit_info = self.available_exploits[exploit_name]
        exploit_path = exploit_info['path']

        # Check if exploit file exists
        if not os.path.exists(exploit_path):
            print(f" Exploit file not found: {exploit_path}")
            return False

        print(f"[TARGET] Running exploit: {exploit_name}")
        print(f"[FILE] Description: {exploit_info['description']}")
        print(f"[DIRECTORY] Path: {exploit_path}")
        print("=" * 50)

        try:
            # Load and execute the exploit module
            spec = importlib.util.spec_from_file_location(exploit_name, exploit_path)
            module = importlib.util.module_from_spec(spec)

            # Set up sys.argv for the exploit
            original_argv = sys.argv
            sys.argv = [exploit_path] + args

            try:
                # Execute the module
                spec.loader.exec_module(module)
                return True
            finally:
                # Restore original sys.argv
                sys.argv = original_argv

        except SystemExit as e:
            # Handle normal exit from exploit
            return e.code == 0
        except Exception as e:
            print(f" Error running exploit: {e}")
            import traceback
            traceback.print_exc()
            return False

    def show_help(self, exploit_name: str = None):
        """Show help information"""
        if exploit_name:
            if exploit_name in self.available_exploits:
                info = self.available_exploits[exploit_name]
                print(f"[TARGET] {exploit_name}")
                print(f"Description: {info['description']}")
                print(f"Usage: {info['usage']}")
            else:
                print(f" Unknown exploit: {exploit_name}")
        else:
            print(" Houdinis Framework - Exploit Runner")
            print("=" * 50)
            print("Usage: python run_exploit.py [options] <exploit_name> [exploit_args...]")
            print()
            print("Options:")
            print("  -l, --list      List all available exploits")
            print("  -h, --help      Show this help message")
            print("  --help <name>   Show help for specific exploit")
            print()
            print("Examples:")
            print("  python run_exploit.py --list")
            print("  python run_exploit.py rsa_shor 15")
            print("  python run_exploit.py grover_bruteforce 5d41402abc4b2a76b9719d911017c592 md5")
            print("  python run_exploit.py ecdsa_vuln_scanner google.com github.com")


def main():
    """Main function"""
    runner = ExploitRunner()

    if len(sys.argv) < 2:
        runner.show_help()
        sys.exit(1)

    # Parse command line arguments
    if sys.argv[1] in ['-l', '--list']:
        runner.list_exploits()
        sys.exit(0)
    elif sys.argv[1] in ['-h', '--help']:
        if len(sys.argv) > 2:
            runner.show_help(sys.argv[2])
        else:
            runner.show_help()
        sys.exit(0)

    # Run exploit
    exploit_name = sys.argv[1]
    exploit_args = sys.argv[2:] if len(sys.argv) > 2 else []

    success = runner.run_exploit(exploit_name, exploit_args)
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
