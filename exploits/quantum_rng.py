#!/usr/bin/env python3
"""
Houdinis Framework - Quantum Random Number Generator
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
License: MIT

Implements quantum random number generation for cryptographic applications
and tests quantum entropy sources.
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    from qiskit import transpile
    import numpy as np
    QUANTUM_AVAILABLE = True
except ImportError:
    QUANTUM_AVAILABLE = False
    print("  Quantum libraries not available, using classical PRNG")

import random
import hashlib
import time
import struct
from typing import Dict, List, Optional
import secrets


class QuantumRNG:
    """Quantum Random Number Generator implementation"""

    def __init__(self):
        """TODO: Add description for __init__"""
        self.name = "Quantum Random Number Generator"
# TODO: Consider breaking this long line (length: 101)
        self.description = "Generate cryptographically secure random numbers using quantum mechanics"
        self.author = "Mauro Risonho de Paula Assumpção aka firebitsbr"
        self.difficulty = "Advanced"
        self.category = "quantum_cryptography"
        self.entropy_buffer = []

    def info(self) -> Dict:
        """Return QRNG information"""
        return {
            'name': self.name,
            'description': self.description,
            'author': self.author,
            'difficulty': self.difficulty,
            'category': self.category,
            'purpose': 'Generate true random numbers for cryptographic applications',
            'quantum_advantage': 'True randomness from quantum superposition collapse',
            'requirements': ['quantum_backend']
        }

    def quantum_coin_flip(self, num_bits: int, backend_type: str = 'simulator') -> Optional[str]:
        """Generate random bits using quantum coin flips"""
        if not QUANTUM_AVAILABLE:
            print(" Quantum libraries not available")
            return None

        try:
            from quantum.backend import QuantumBackendManager
            backend_manager = QuantumBackendManager()

            backend = backend_manager.get_backend()
            if not backend:
                print(" No quantum backend available")
                return None

            # Limit to reasonable number of qubits for simulation
            max_qubits = min(num_bits, 20)

            # Create quantum circuit
            qreg = QuantumRegister(max_qubits, 'q')
            creg = ClassicalRegister(max_qubits, 'c')
            qc = QuantumCircuit(qreg, creg)

            # Apply Hadamard gates for superposition (coin flip)
            qc.h(qreg)

            # Measure all qubits
            qc.measure(qreg, creg)

            print(f"[RANDOM] Generating {max_qubits} quantum random bits...")

            # Execute circuit
            transpiled = transpile(qc, backend)
            job = backend.run(transpiled, shots=1)
            result = job.result()
            counts = result.get_counts()

            # Extract random bits from measurement
            if counts:
                # Get the most frequent result (should be random)
                random_bitstring = max(counts, key=counts.get)

                # If we need more bits than we generated, repeat the process
                if num_bits > max_qubits:
                    remaining_bits = num_bits - max_qubits
                    additional_bits = self.quantum_coin_flip(remaining_bits, backend_type)
                    if additional_bits:
                        random_bitstring += additional_bits

                return random_bitstring[:num_bits]
            else:
                return None

        except Exception as e:
            print(f" Quantum RNG error: {e}")
            return None

    def classical_fallback_rng(self, num_bits: int) -> str:
        """Classical cryptographically secure random number generator fallback"""
        print(f"[LOADING] Using classical CSPRNG fallback for {num_bits} bits")

        # Use system entropy source
        random_bytes = secrets.randbits(num_bits)
        return format(random_bytes, f'0{num_bits}b')

    def test_randomness_quality(self, bit_sequence: str) -> Dict:
        """Test the quality of random bit sequence"""
        if not bit_sequence:
            return {'error': 'No bit sequence provided'}

        n = len(bit_sequence)
        ones = bit_sequence.count('1')
        zeros = bit_sequence.count('0')

        analysis = {
            'sequence_length': n,
            'ones_count': ones,
            'zeros_count': zeros,
            'balance_ratio': ones / n if n > 0 else 0,
            'tests': {}
        }

        # Frequency test (monobit test)
        frequency_score = abs(0.5 - analysis['balance_ratio'])
        analysis['tests']['frequency'] = {
            'score': frequency_score,
            'pass': frequency_score < 0.1,
            'description': 'Tests if ratio of 1s and 0s is approximately 1:1'
        }

        # Runs test
        runs = 1
        for i in range(1, n):
            if bit_sequence[i] != bit_sequence[i-1]:
                runs += 1

        expected_runs = (2 * ones * zeros / n) + 1 if n > 0 else 0
        runs_score = abs(runs - expected_runs) / expected_runs if expected_runs > 0 else 1

        analysis['tests']['runs'] = {
            'observed_runs': runs,
            'expected_runs': expected_runs,
            'score': runs_score,
            'pass': runs_score < 0.3,
            'description': 'Tests for clustering of bits'
        }

        # Serial correlation test (simplified)
        if n > 1:
            matches = sum(1 for i in range(n-1) if bit_sequence[i] == bit_sequence[i+1])
            correlation_score = abs(matches - n/4) / (n/4) if n > 0 else 1

            analysis['tests']['serial_correlation'] = {
                'matches': matches,
                'score': correlation_score,
                'pass': correlation_score < 0.3,
                'description': 'Tests for correlation between consecutive bits'
            }

        # Overall quality assessment
        passed_tests = sum(1 for test in analysis['tests'].values() if test.get('pass', False))
        total_tests = len(analysis['tests'])

        analysis['overall_quality'] = {
            'passed_tests': passed_tests,
            'total_tests': total_tests,
            'pass_rate': passed_tests / total_tests if total_tests > 0 else 0,
            'quality_grade': 'EXCELLENT' if passed_tests == total_tests else
                           'GOOD' if passed_tests >= total_tests * 0.8 else
                           'FAIR' if passed_tests >= total_tests * 0.6 else 'POOR'
        }

        return analysis

    def extract_entropy(self, bit_sequence: str) -> float:
        """Calculate Shannon entropy of bit sequence"""
        if not bit_sequence:
            return 0.0

        # Count occurrences of each bit value
        ones = bit_sequence.count('1')
        zeros = bit_sequence.count('0')
        total = len(bit_sequence)

        if total == 0:
            return 0.0

        # Calculate probabilities
        p_zero = zeros / total if total > 0 else 0
        p_one = ones / total if total > 0 else 0

        # Calculate Shannon entropy
        entropy = 0.0
        if p_zero > 0:
            entropy -= p_zero * np.log2(p_zero)
        if p_one > 0:
            entropy -= p_one * np.log2(p_one)

        return entropy

    def generate_random_bytes(self, num_bytes: int, use_quantum: bool = True) -> bytes:
        """Generate random bytes using quantum or classical methods"""
        num_bits = num_bytes * 8

        print(f"[RANDOM] Generating {num_bytes} random bytes ({num_bits} bits)")

        if use_quantum and QUANTUM_AVAILABLE:
            bit_sequence = self.quantum_coin_flip(num_bits)
            if bit_sequence:
                print(" Using quantum random number generation")
            else:
                print("  Quantum RNG failed, falling back to classical")
                bit_sequence = self.classical_fallback_rng(num_bits)
        else:
            bit_sequence = self.classical_fallback_rng(num_bits)

        # Convert bit string to bytes
        random_bytes = bytearray()
        for i in range(0, len(bit_sequence), 8):
            byte_bits = bit_sequence[i:i+8]
            if len(byte_bits) == 8:
                byte_value = int(byte_bits, 2)
                random_bytes.append(byte_value)

        return bytes(random_bytes)

    def benchmark_rng_performance(self, num_samples: int = 1000) -> Dict:
        """Benchmark RNG performance"""
        print(f"[RUNNING] Benchmarking RNG performance with {num_samples} samples...")

        benchmark_results = {
            'classical': {'time': 0, 'entropy': 0, 'quality': {}},
            'quantum': {'time': 0, 'entropy': 0, 'quality': {}}
        }

        # Benchmark classical RNG
        start_time = time.time()
        classical_bits = self.classical_fallback_rng(num_samples)
        classical_time = time.time() - start_time

        classical_entropy = self.extract_entropy(classical_bits)
        classical_quality = self.test_randomness_quality(classical_bits)

        benchmark_results['classical'] = {
            'time': classical_time,
            'entropy': classical_entropy,
            'quality': classical_quality,
            'bits_per_second': num_samples / classical_time if classical_time > 0 else 0
        }

        print(f" Classical RNG: {classical_time:.4f}s, entropy: {classical_entropy:.4f}")

        # Benchmark quantum RNG (if available)
        if QUANTUM_AVAILABLE:
            start_time = time.time()
            quantum_bits = self.quantum_coin_flip(min(num_samples, 100))  # Limit for simulation
            quantum_time = time.time() - start_time

            if quantum_bits:
                quantum_entropy = self.extract_entropy(quantum_bits)
                quantum_quality = self.test_randomness_quality(quantum_bits)

                benchmark_results['quantum'] = {
                    'time': quantum_time,
                    'entropy': quantum_entropy,
                    'quality': quantum_quality,
                    'bits_per_second': len(quantum_bits) / quantum_time if quantum_time > 0 else 0
                }

                print(f" Quantum RNG: {quantum_time:.4f}s, entropy: {quantum_entropy:.4f}")
            else:
                benchmark_results['quantum'] = {'error': 'Quantum RNG failed'}
        else:
            benchmark_results['quantum'] = {'error': 'Quantum libraries not available'}

        return benchmark_results

    def generate_cryptographic_key(self, key_size: int, key_type: str = 'AES') -> Dict:
        """Generate cryptographic key using quantum RNG"""
        print(f" Generating {key_size}-bit {key_type} key using quantum RNG")

        # Generate random key material
        key_bytes = self.generate_random_bytes(key_size // 8, use_quantum=True)

        # Test key quality
        key_bits = ''.join(format(b, '08b') for b in key_bytes)
        quality_analysis = self.test_randomness_quality(key_bits)
        entropy = self.extract_entropy(key_bits)

        key_info = {
            'key_type': key_type,
            'key_size_bits': key_size,
            'key_size_bytes': len(key_bytes),
            'key_hex': key_bytes.hex(),
            'key_base64': __import__('base64').b64encode(key_bytes).decode(),
            'entropy': entropy,
            'quality_analysis': quality_analysis,
            'generation_method': 'quantum' if QUANTUM_AVAILABLE else 'classical',
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
        }

        print(f" Generated {key_size}-bit key")
        print(f"   Entropy: {entropy:.4f} bits per bit")
        print(f"   Quality: {quality_analysis['overall_quality']['quality_grade']}")

        return key_info

    def run(self, operation: str, **kwargs) -> Dict:
        """Run quantum RNG operations"""
        try:
            print(f"[RANDOM] Quantum Random Number Generator")
            print(f"=" * 50)

            if operation == 'generate_bits':
                num_bits = kwargs.get('num_bits', 32)
                use_quantum = kwargs.get('use_quantum', True)

                if use_quantum and QUANTUM_AVAILABLE:
                    bits = self.quantum_coin_flip(num_bits)
                    method = 'quantum'
                else:
                    bits = self.classical_fallback_rng(num_bits)
                    method = 'classical'

                if bits:
                    quality = self.test_randomness_quality(bits)
                    entropy = self.extract_entropy(bits)

                    return {
                        'success': True,
                        'operation': 'generate_bits',
                        'bits': bits,
                        'num_bits': len(bits),
                        'method': method,
                        'entropy': entropy,
                        'quality': quality
                    }
                else:
                    return {'success': False, 'error': 'Failed to generate random bits'}

            elif operation == 'generate_key':
                key_size = kwargs.get('key_size', 256)
                key_type = kwargs.get('key_type', 'AES')

                key_info = self.generate_cryptographic_key(key_size, key_type)

                return {
                    'success': True,
                    'operation': 'generate_key',
                    'key_info': key_info
                }

            elif operation == 'benchmark':
                num_samples = kwargs.get('num_samples', 1000)
                benchmark_results = self.benchmark_rng_performance(num_samples)

                return {
                    'success': True,
                    'operation': 'benchmark',
                    'benchmark_results': benchmark_results
                }

            else:
                return {
                    'success': False,
                    'error': f'Unknown operation: {operation}'
                }

        except Exception as e:
            error_msg = f"QRNG operation error: {e}"
            print(f" {error_msg}")
            return {'success': False, 'error': error_msg}


def main():
    """CLI interface for Quantum RNG"""
    if len(sys.argv) < 2:
        print("Usage: python quantum_rng.py <operation> [options]")
        print("Operations:")
        print("  bits <num_bits> - Generate random bits")
        print("  key <key_size> [key_type] - Generate cryptographic key")
        print("  benchmark [num_samples] - Benchmark RNG performance")
        print("Examples:")
        print("  python quantum_rng.py bits 64")
        print("  python quantum_rng.py key 256 AES")
        print("  python quantum_rng.py benchmark 1000")
        sys.exit(1)

    operation = sys.argv[1]
    qrng = QuantumRNG()

    if operation == 'bits':
        num_bits = int(sys.argv[2]) if len(sys.argv) > 2 else 32
        result = qrng.run('generate_bits', num_bits=num_bits)

        if result['success']:
            print(f"\n[TARGET] Generated {result['num_bits']} random bits:")
            print(f"Bits: {result['bits']}")
            print(f"Method: {result['method']}")
            print(f"Entropy: {result['entropy']:.4f}")
            print(f"Quality: {result['quality']['overall_quality']['quality_grade']}")

    elif operation == 'key':
        key_size = int(sys.argv[2]) if len(sys.argv) > 2 else 256
        key_type = sys.argv[3] if len(sys.argv) > 3 else 'AES'
        result = qrng.run('generate_key', key_size=key_size, key_type=key_type)

        if result['success']:
            key_info = result['key_info']
            print(f"\n Generated {key_size}-bit {key_type} key:")
            print(f"Hex: {key_info['key_hex']}")
            print(f"Base64: {key_info['key_base64']}")
            print(f"Entropy: {key_info['entropy']:.4f}")
            print(f"Quality: {key_info['quality_analysis']['overall_quality']['quality_grade']}")

    elif operation == 'benchmark':
        num_samples = int(sys.argv[2]) if len(sys.argv) > 2 else 1000
        result = qrng.run('benchmark', num_samples=num_samples)

        if result['success']:
            benchmark = result['benchmark_results']
            print(f"\n RNG Benchmark Results:")

            if 'classical' in benchmark:
                classical = benchmark['classical']
                print(f"Classical RNG:")
                print(f"  Time: {classical['time']:.4f}s")
                print(f"  Entropy: {classical['entropy']:.4f}")
                print(f"  Speed: {classical['bits_per_second']:.0f} bits/sec")

            if 'quantum' in benchmark and 'error' not in benchmark['quantum']:
                quantum = benchmark['quantum']
                print(f"Quantum RNG:")
                print(f"  Time: {quantum['time']:.4f}s")
                print(f"  Entropy: {quantum['entropy']:.4f}")
                print(f"  Speed: {quantum['bits_per_second']:.0f} bits/sec")
    else:
        print(f" Unknown operation: {operation}")
        sys.exit(1)

    if result['success']:
        print(f"\n[TARGET] Operation completed successfully!")
        sys.exit(0)
    else:
        print(f"\n Operation failed: {result.get('error', 'Unknown error')}")
        sys.exit(1)


if __name__ == "__main__":
    main()
