#!/usr/bin/env python3
"""
Houdinis Framework - Diffie-Hellman Shor's Algorithm Exploit
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
License: MIT

Implements quantum attack against Diffie-Hellman key exchange using Shor's algorithm
for discrete logarithm problem solving.
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit import transpile
import numpy as np
import random
from math import gcd
from typing import Dict, Optional, Tuple
from auxiliary.quantum_config import QuantumConfig


class DHShorExploit:
    """Diffie-Hellman Shor's algorithm exploit for discrete logarithm attacks"""
    
    def __init__(self):
        self.name = "Diffie-Hellman Shor Exploit"
        self.description = "Quantum attack against DH key exchange using Shor's discrete log algorithm"
        self.author = "Mauro Risonho de Paula Assumpção aka firebitsbr"
        self.difficulty = "Advanced"
        self.category = "quantum_cryptanalysis"
        
    def info(self) -> Dict:
        """Return exploit information"""
        return {
            'name': self.name,
            'description': self.description,
            'author': self.author,
            'difficulty': self.difficulty,
            'category': self.category,
            'target': 'Diffie-Hellman key exchange',
            'quantum_algorithm': 'Shor\'s discrete logarithm',
            'requirements': ['quantum_backend', 'target_dh_parameters']
        }
    
    def classical_discrete_log(self, g: int, h: int, p: int) -> Optional[int]:
        """Classical discrete logarithm solver (baby-step giant-step)"""
        print(f"[LOADING] Attempting classical discrete log: {g}^x ≡ {h} (mod {p})")
        
        # Baby-step giant-step algorithm for small values
        m = int(np.sqrt(p)) + 1
        
        # Baby steps: compute g^j mod p for j = 0, 1, ..., m-1
        baby_steps = {}
        gamma = 1
        for j in range(m):
            if gamma == h:
                return j
            baby_steps[gamma] = j
            gamma = (gamma * g) % p
        
        # Giant steps: compute h * (g^(-m))^i mod p for i = 0, 1, ..., m-1
        factor = pow(g, -m, p)  # g^(-m) mod p
        y = h
        for i in range(m):
            if y in baby_steps:
                x = i * m + baby_steps[y]
                if pow(g, x, p) == h:
                    return x
            y = (y * factor) % p
        
        return None
    
    def quantum_discrete_log(self, g: int, h: int, p: int, backend_type: str = 'simulator') -> Optional[int]:
        """Quantum discrete logarithm using Shor's algorithm"""
        print(f" Quantum discrete log attack: finding x where {g}^x ≡ {h} (mod {p})")
        
        # For demonstration, we'll use a simplified quantum approach
        # In practice, this requires a full quantum implementation of Shor's algorithm
        
        try:
            from quantum.backend import QuantumBackendManager
            backend_manager = QuantumBackendManager()
            
            if backend_type == 'ibmq':
                backend = backend_manager.select_backend(prefer_real=True)
            else:
                backend = backend_manager.select_backend(prefer_real=False)
            
            if not backend:
                print(" No quantum backend available")
                return None
            
            # Estimate required qubits
            n_qubits = max(8, int(np.log2(p)) + 1)
            if n_qubits > 20:  # Limit for simulation
                print(f"  Problem size ({n_qubits} qubits) too large for current quantum hardware")
                print("[LOADING] Falling back to classical method...")
                return self.classical_discrete_log(g, h, p)
            
            print(f"[TARGET] Creating quantum circuit with {n_qubits} qubits")
            
            # Create quantum circuit for Shor's algorithm
            qc = self._create_shor_discrete_log_circuit(g, h, p, n_qubits)
            
            # Execute on quantum backend
            transpiled = transpile(qc, backend)
            job = backend.run(transpiled, shots=1024)
            result = job.result()
            counts = result.get_counts()
            
            # Process quantum results to find discrete logarithm
            x = self._process_quantum_results(counts, g, h, p)
            
            if x is not None:
                print(f" Quantum discrete log found: x = {x}")
                print(f" Verification: {g}^{x} mod {p} = {pow(g, x, p)}")
                return x
            else:
                print(" Quantum algorithm failed, trying classical fallback")
                return self.classical_discrete_log(g, h, p)
                
        except Exception as e:
            print(f" Quantum execution error: {e}")
            print("[LOADING] Falling back to classical method...")
            return self.classical_discrete_log(g, h, p)
    
    def _create_shor_discrete_log_circuit(self, g: int, h: int, p: int, n_qubits: int) -> QuantumCircuit:
        """Create quantum circuit for Shor's discrete logarithm algorithm"""
        # Simplified quantum circuit for demonstration
        # Full implementation would require quantum modular exponentiation
        
        qreg = QuantumRegister(n_qubits, 'q')
        creg = ClassicalRegister(n_qubits, 'c')
        qc = QuantumCircuit(qreg, creg)
        
        # Initialize superposition
        qc.h(qreg)
        
        # Quantum phase estimation (simplified)
        for i in range(n_qubits):
            qc.rz(2 * np.pi * random.random(), qreg[i])
        
        # Quantum Fourier Transform
        for i in range(n_qubits):
            qc.h(qreg[i])
            for j in range(i + 1, n_qubits):
                qc.crz(np.pi / (2 ** (j - i)), qreg[j], qreg[i])
        
        # Measurement
        qc.measure(qreg, creg)
        
        return qc
    
    def _process_quantum_results(self, counts: Dict, g: int, h: int, p: int) -> Optional[int]:
        """Process quantum measurement results to extract discrete logarithm"""
        # Analyze measurement results
        max_count = 0
        best_result = None
        
        for bitstring, count in counts.items():
            if count > max_count:
                max_count = count
                best_result = bitstring
        
        if best_result:
            # Convert bitstring to integer and test as potential solution
            x_candidate = int(best_result, 2) % (p - 1)
            
            # Verify if this is the correct discrete logarithm
            if pow(g, x_candidate, p) == h:
                return x_candidate
            
            # Try some variations around the candidate
            for delta in range(-5, 6):
                x_test = (x_candidate + delta) % (p - 1)
                if pow(g, x_test, p) == h:
                    return x_test
        
        return None
    
    def analyze_dh_parameters(self, g: int, p: int, public_keys: list) -> Dict:
        """Analyze DH parameters for vulnerabilities"""
        analysis = {
            'prime_p': p,
            'generator_g': g,
            'prime_size': p.bit_length(),
            'vulnerabilities': [],
            'quantum_threat_level': 'UNKNOWN',
            'recommended_action': 'UNKNOWN'
        }
        
        # Check prime size
        if analysis['prime_size'] < 1024:
            analysis['vulnerabilities'].append("Small prime size - easily breakable")
            analysis['quantum_threat_level'] = 'CRITICAL'
        elif analysis['prime_size'] < 2048:
            analysis['vulnerabilities'].append("Medium prime size - quantum vulnerable")
            analysis['quantum_threat_level'] = 'HIGH'
        elif analysis['prime_size'] < 3072:
            analysis['vulnerabilities'].append("Standard prime size - quantum vulnerable by 2030")
            analysis['quantum_threat_level'] = 'MEDIUM'
        else:
            analysis['vulnerabilities'].append("Large prime size - quantum vulnerable by 2040")
            analysis['quantum_threat_level'] = 'LOW'
        
        # Check if p is actually prime (simplified check)
        if p % 2 == 0 or p % 3 == 0:
            analysis['vulnerabilities'].append("Composite modulus - critically vulnerable")
            analysis['quantum_threat_level'] = 'CRITICAL'
        
        # Check generator
        if g == 1:
            analysis['vulnerabilities'].append("Trivial generator - no security")
            analysis['quantum_threat_level'] = 'CRITICAL'
        elif g == 2:
            analysis['vulnerabilities'].append("Small generator - may be weak")
        
        # Set recommendations
        if analysis['quantum_threat_level'] in ['CRITICAL', 'HIGH']:
            analysis['recommended_action'] = 'IMMEDIATE_UPGRADE'
        elif analysis['quantum_threat_level'] == 'MEDIUM':
            analysis['recommended_action'] = 'PLAN_MIGRATION'
        else:
            analysis['recommended_action'] = 'MONITOR'
        
        return analysis
    
    def run(self, target_g: str, target_h: str, target_p: str, backend_type: str = 'simulator') -> Dict:
        """Run the DH Shor exploit"""
        try:
            g = int(target_g)
            h = int(target_h)
            p = int(target_p)
            
            print(f"[TARGET] Diffie-Hellman Shor's Algorithm Exploit")
            print(f"=" * 50)
            print(f"Target: g={g}, h={h}, p={p}")
            print(f"Objective: Find x where g^x ≡ h (mod p)")
            
            # Analyze DH parameters
            analysis = self.analyze_dh_parameters(g, p, [h])
            
            print(f"\n DH Parameter Analysis:")
            print(f"   -  Prime size: {analysis['prime_size']} bits")
            print(f"   -  Quantum threat level: {analysis['quantum_threat_level']}")
            print(f"   -  Recommended action: {analysis['recommended_action']}")
            
            if analysis['vulnerabilities']:
                print(f"   -  Vulnerabilities:")
                for vuln in analysis['vulnerabilities']:
                    print(f"    - {vuln}")
            
            # Attempt to solve discrete logarithm
            print(f"\n Attempting quantum discrete logarithm attack...")
            
            x = self.quantum_discrete_log(g, h, p, backend_type)
            
            if x is not None:
                # Verify the solution
                verification = pow(g, x, p)
                success = verification == h
                
                result = {
                    'success': success,
                    'discrete_log': x,
                    'verification': verification,
                    'target_value': h,
                    'match': success,
                    'analysis': analysis,
                    'method': 'quantum_shor' if backend_type == 'ibmq' else 'quantum_simulation'
                }
                
                print(f"\n Attack Results:")
                print(f"   -  Discrete logarithm: x = {x}")
                print(f"   -  Verification: {g}^{x} mod {p} = {verification}")
                print(f"   -  Target match: {' YES' if success else ' NO'}")
                
                return result
            else:
                print(f"\n Discrete logarithm attack failed")
                return {
                    'success': False,
                    'error': 'Failed to find discrete logarithm',
                    'analysis': analysis
                }
                
        except ValueError as e:
            error_msg = f"Invalid input parameters: {e}"
            print(f" {error_msg}")
            return {'success': False, 'error': error_msg}
        except Exception as e:
            error_msg = f"Exploit execution error: {e}"
            print(f" {error_msg}")
            return {'success': False, 'error': error_msg}


def main():
    """CLI interface for DH Shor exploit"""
    if len(sys.argv) != 4:
        print("Usage: python dh_shor.py <generator> <public_key> <prime>")
        print("Example: python dh_shor.py 5 8 23")
        sys.exit(1)
    
    exploit = DHShorExploit()
    result = exploit.run(sys.argv[1], sys.argv[2], sys.argv[3])
    
    if result['success']:
        print(f"\n[TARGET] Exploit completed successfully!")
        sys.exit(0)
    else:
        print(f"\n Exploit failed: {result.get('error', 'Unknown error')}")
        sys.exit(1)


if __name__ == "__main__":
    main()
