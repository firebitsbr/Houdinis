#!/usr/bin/env python3
"""
Houdinis Framework - ECDSA Vulnerability Scanner
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
License: MIT

Scans for ECDSA implementations vulnerable to quantum attacks
and assesses elliptic curve cryptography weaknesses.
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import socket
import ssl
import subprocess
import re
import json
from typing import Dict, List, Optional, Tuple
import datetime


class ECDSAVulnScanner:
    """Scanner for ECDSA quantum vulnerabilities"""
    
    def __init__(self):
        self.name = "ECDSA Vulnerability Scanner"
        self.description = "Quantum vulnerability assessment for ECDSA implementations"
        self.author = "Mauro Risonho de Paula Assumpção aka firebitsbr"
        self.difficulty = "Intermediate"
        self.category = "vulnerability_scanning"
        
    def info(self) -> Dict:
        """Return scanner information"""
        return {
            'name': self.name,
            'description': self.description,
            'author': self.author,
            'difficulty': self.difficulty,
            'category': self.category,
            'target': 'ECDSA implementations and elliptic curve crypto',
            'quantum_threat': 'Shor\'s algorithm breaks ECDSA signatures',
            'requirements': ['network_access', 'ssl_inspection_capability']
        }
    
    def get_ecdsa_curves_info(self) -> Dict:
        """Get information about common ECDSA curves and their quantum resistance"""
        return {
            'secp256r1': {
                'name': 'P-256',
                'key_size': 256,
                'security_level': 128,
                'quantum_security': 0,
                'break_timeline': '2030-2035',
                'risk_level': 'HIGH',
                'description': 'Most common curve, widely supported'
            },
            'secp384r1': {
                'name': 'P-384',
                'key_size': 384,
                'security_level': 192,
                'quantum_security': 0,
                'break_timeline': '2035-2040',
                'risk_level': 'MEDIUM',
                'description': 'Higher security than P-256'
            },
            'secp521r1': {
                'name': 'P-521',
                'key_size': 521,
                'security_level': 256,
                'quantum_security': 0,
                'break_timeline': '2040-2045',
                'risk_level': 'MEDIUM',
                'description': 'Highest NIST curve'
            },
            'prime256v1': {
                'name': 'prime256v1',
                'key_size': 256,
                'security_level': 128,
                'quantum_security': 0,
                'break_timeline': '2030-2035',
                'risk_level': 'HIGH',
                'description': 'Alternative name for P-256'
            },
            'secp256k1': {
                'name': 'secp256k1',
                'key_size': 256,
                'security_level': 128,
                'quantum_security': 0,
                'break_timeline': '2030-2035',
                'risk_level': 'HIGH',
                'description': 'Bitcoin curve'
            }
        }
    
    def scan_ssl_certificate(self, hostname: str, port: int = 443) -> Optional[Dict]:
        """Scan SSL certificate for ECDSA usage"""
        try:
            print(f" Scanning SSL certificate for {hostname}:{port}")
            
            # Create SSL context
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            # Connect and get certificate
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert(binary_form=True)
                    cert_text = ssock.getpeercert()
                    cipher_info = ssock.cipher()
                    
            if not cert or not cert_text:
                return None
            
            # Analyze certificate
            cert_analysis = {
                'hostname': hostname,
                'port': port,
                'timestamp': datetime.datetime.now().isoformat(),
                'subject': cert_text.get('subject', []),
                'issuer': cert_text.get('issuer', []),
                'version': cert_text.get('version', 'Unknown'),
                'serial_number': cert_text.get('serialNumber', 'Unknown'),
                'not_before': cert_text.get('notBefore', 'Unknown'),
                'not_after': cert_text.get('notAfter', 'Unknown'),
                'signature_algorithm': 'Unknown',
                'public_key_algorithm': 'Unknown',
                'public_key_size': 0,
                'curve_name': 'Unknown',
                'cipher_suite': cipher_info[0] if cipher_info else 'Unknown',
                'tls_version': ssock.version() if hasattr(ssock, 'version') else 'Unknown',
                'uses_ecdsa': False,
                'quantum_vulnerable': False,
                'risk_assessment': {}
            }
            
            # Try to extract more details using openssl command
            try:
                # Write certificate to temporary file for analysis
                with open('/tmp/cert.pem', 'wb') as f:
                    f.write(ssl.DER_cert_to_PEM_cert(cert).encode())
                
                # Use openssl to get detailed certificate information
                result = subprocess.run([
                    'openssl', 'x509', '-in', '/tmp/cert.pem', '-text', '-noout'
                ], capture_output=True, text=True, timeout=10)
                
                if result.returncode == 0:
                    cert_details = result.stdout
                    
                    # Extract signature algorithm
                    sig_match = re.search(r'Signature Algorithm: (.+)', cert_details)
                    if sig_match:
                        cert_analysis['signature_algorithm'] = sig_match.group(1).strip()
                        if 'ecdsa' in cert_analysis['signature_algorithm'].lower():
                            cert_analysis['uses_ecdsa'] = True
                    
                    # Extract public key information
                    pubkey_match = re.search(r'Public Key Algorithm: (.+)', cert_details)
                    if pubkey_match:
                        cert_analysis['public_key_algorithm'] = pubkey_match.group(1).strip()
                    
                    # Extract key size and curve for EC keys
                    if 'EC' in cert_analysis['public_key_algorithm'] or 'elliptic' in cert_details.lower():
                        cert_analysis['uses_ecdsa'] = True
                        
                        # Try to find curve name
                        curve_match = re.search(r'ASN1 OID: (.+)', cert_details)
                        if curve_match:
                            cert_analysis['curve_name'] = curve_match.group(1).strip()
                        
                        # Try to find key size
                        size_match = re.search(r'(\d+) bit', cert_details)
                        if size_match:
                            cert_analysis['public_key_size'] = int(size_match.group(1))
                
                # Clean up temporary file
                os.remove('/tmp/cert.pem')
                
            except Exception as e:
                print(f"  Could not analyze certificate details: {e}")
            
            # Perform quantum vulnerability assessment
            if cert_analysis['uses_ecdsa']:
                cert_analysis['risk_assessment'] = self.assess_ecdsa_risk(
                    cert_analysis['curve_name'],
                    cert_analysis['public_key_size']
                )
                cert_analysis['quantum_vulnerable'] = True
            
            return cert_analysis
            
        except Exception as e:
            print(f" Failed to scan certificate: {e}")
            return None
    
    def assess_ecdsa_risk(self, curve_name: str, key_size: int) -> Dict:
        """Assess quantum risk for ECDSA configuration"""
        curves_info = self.get_ecdsa_curves_info()
        
        risk_assessment = {
            'curve_identified': False,
            'curve_info': {},
            'risk_level': 'UNKNOWN',
            'break_timeline': 'UNKNOWN',
            'quantum_security_bits': 0,
            'recommendations': [],
            'urgency': 'UNKNOWN'
        }
        
        # Try to identify the curve
        curve_key = None
        for key, info in curves_info.items():
            if (key.lower() in curve_name.lower() or 
                info['name'].lower() in curve_name.lower() or
                (key_size > 0 and info['key_size'] == key_size)):
                curve_key = key
                break
        
        if curve_key:
            risk_assessment['curve_identified'] = True
            risk_assessment['curve_info'] = curves_info[curve_key]
            risk_assessment['risk_level'] = curves_info[curve_key]['risk_level']
            risk_assessment['break_timeline'] = curves_info[curve_key]['break_timeline']
            risk_assessment['quantum_security_bits'] = curves_info[curve_key]['quantum_security']
        else:
            # Generic assessment based on key size
            if key_size > 0:
                if key_size < 256:
                    risk_assessment['risk_level'] = 'CRITICAL'
                    risk_assessment['break_timeline'] = '2025-2030'
                elif key_size < 384:
                    risk_assessment['risk_level'] = 'HIGH'
                    risk_assessment['break_timeline'] = '2030-2035'
                elif key_size < 521:
                    risk_assessment['risk_level'] = 'MEDIUM'
                    risk_assessment['break_timeline'] = '2035-2040'
                else:
                    risk_assessment['risk_level'] = 'MEDIUM'
                    risk_assessment['break_timeline'] = '2040+'
        
        # Generate recommendations
        if risk_assessment['risk_level'] == 'CRITICAL':
            risk_assessment['recommendations'] = [
                'IMMEDIATE: Replace with post-quantum cryptography',
                'Use hybrid classical/PQ solutions during transition',
                'Revoke and reissue certificates immediately'
            ]
            risk_assessment['urgency'] = 'IMMEDIATE'
        elif risk_assessment['risk_level'] == 'HIGH':
            risk_assessment['recommendations'] = [
                'Plan migration to post-quantum cryptography within 2 years',
                'Implement crypto-agility for rapid algorithm updates',
                'Monitor quantum computing developments'
            ]
            risk_assessment['urgency'] = 'HIGH'
        elif risk_assessment['risk_level'] == 'MEDIUM':
            risk_assessment['recommendations'] = [
                'Plan migration to post-quantum cryptography within 5 years',
                'Prepare for algorithm transitions',
                'Consider hybrid solutions for long-term data'
            ]
            risk_assessment['urgency'] = 'MEDIUM'
        else:
            risk_assessment['recommendations'] = [
                'Continue monitoring quantum threat developments',
                'Prepare for eventual migration to post-quantum crypto'
            ]
            risk_assessment['urgency'] = 'LOW'
        
        return risk_assessment
    
    def scan_multiple_hosts(self, hostnames: List[str], port: int = 443) -> List[Dict]:
        """Scan multiple hosts for ECDSA vulnerabilities"""
        results = []
        
        for hostname in hostnames:
            print(f"\n[TARGET] Scanning {hostname}...")
            result = self.scan_ssl_certificate(hostname, port)
            if result:
                results.append(result)
            else:
                print(f" Failed to scan {hostname}")
        
        return results
    
    def generate_vulnerability_report(self, scan_results: List[Dict]) -> str:
        """Generate comprehensive vulnerability report"""
        if not scan_results:
            return "No scan results available"
        
        # Analyze results
        total_hosts = len(scan_results)
        ecdsa_hosts = sum(1 for r in scan_results if r.get('uses_ecdsa', False))
        vulnerable_hosts = sum(1 for r in scan_results if r.get('quantum_vulnerable', False))
        
        risk_distribution = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0, 'UNKNOWN': 0}
        curves_used = {}
        
        for result in scan_results:
            if result.get('risk_assessment'):
                risk_level = result['risk_assessment'].get('risk_level', 'UNKNOWN')
                risk_distribution[risk_level] += 1
                
                curve_name = result.get('curve_name', 'Unknown')
                if curve_name not in curves_used:
                    curves_used[curve_name] = 0
                curves_used[curve_name] += 1
        
        report = f"""
 ECDSA QUANTUM VULNERABILITY ASSESSMENT REPORT
================================================================

 SCAN SUMMARY:
   -  Total hosts scanned: {total_hosts}
   -  Hosts using ECDSA: {ecdsa_hosts}
   -  Quantum-vulnerable hosts: {vulnerable_hosts}
   -  Vulnerability rate: {(vulnerable_hosts/total_hosts*100):.1f}%

  RISK DISTRIBUTION:
   -  Critical risk: {risk_distribution['CRITICAL']} hosts
   -  High risk: {risk_distribution['HIGH']} hosts
   -  Medium risk: {risk_distribution['MEDIUM']} hosts
   -  Low risk: {risk_distribution['LOW']} hosts
   -  Unknown risk: {risk_distribution['UNKNOWN']} hosts

[STATS] ELLIPTIC CURVES DETECTED:
"""
        
        for curve, count in curves_used.items():
            percentage = (count / total_hosts) * 100
            report += f"   -  {curve}: {count} hosts ({percentage:.1f}%)\n"
        
        report += f"""
[TARGET] DETAILED FINDINGS:
"""
        
        for result in scan_results:
            status = "[CRITICAL] VULNERABLE" if result.get('quantum_vulnerable') else "🟢 SECURE"
            risk_level = result.get('risk_assessment', {}).get('risk_level', 'UNKNOWN')
            timeline = result.get('risk_assessment', {}).get('break_timeline', 'UNKNOWN')
            
            report += f"""
  Host: {result['hostname']}:{result['port']}
  Status: {status}
  ECDSA Usage: {'Yes' if result.get('uses_ecdsa') else 'No'}
  Signature Algorithm: {result.get('signature_algorithm', 'Unknown')}
  Curve: {result.get('curve_name', 'Unknown')}
  Key Size: {result.get('public_key_size', 'Unknown')} bits
  Risk Level: {risk_level}
  Break Timeline: {timeline}
  TLS Version: {result.get('tls_version', 'Unknown')}
  Cipher Suite: {result.get('cipher_suite', 'Unknown')}
"""
            
            if result.get('risk_assessment', {}).get('recommendations'):
                report += "  Recommendations:\n"
                for rec in result['risk_assessment']['recommendations']:
                    report += f"     -  {rec}\n"
        
        report += f"""
[ALERT] IMMEDIATE ACTIONS REQUIRED:
  1. Inventory all ECDSA certificates and implementations
  2. Plan migration to post-quantum signature algorithms
  3. Implement certificate lifecycle management
  4. Monitor quantum computing threat developments
  5. Prepare for hybrid classical/post-quantum solutions

 QUANTUM THREAT TIMELINE:
   -  2025-2030: Weak elliptic curves vulnerable
   -  2030-2035: P-256 and similar curves broken
   -  2035-2040: P-384 and stronger curves vulnerable
   -  2040+: All classical elliptic curve crypto assumed broken

[LEGAL]  LEGAL NOTICE:
This assessment is for authorized security testing only.
Ensure compliance with applicable laws and regulations.
"""
        
        return report
    
    def run(self, target_hosts: List[str], port: int = 443) -> Dict:
        """Run the ECDSA vulnerability scanner"""
        try:
            print(f" ECDSA Quantum Vulnerability Scanner")
            print(f"=" * 50)
            print(f"Targets: {', '.join(target_hosts)}")
            print(f"Port: {port}")
            
            # Scan all targets
            scan_results = self.scan_multiple_hosts(target_hosts, port)
            
            if not scan_results:
                return {
                    'success': False,
                    'error': 'No successful scans completed'
                }
            
            # Generate report
            report = self.generate_vulnerability_report(scan_results)
            
            # Summary statistics
            vulnerable_count = sum(1 for r in scan_results if r.get('quantum_vulnerable', False))
            ecdsa_count = sum(1 for r in scan_results if r.get('uses_ecdsa', False))
            
            print(f"\n Scan Complete!")
            print(f"   -  Hosts scanned: {len(scan_results)}")
            print(f"   -  ECDSA usage detected: {ecdsa_count}")
            print(f"   -  Quantum vulnerable: {vulnerable_count}")
            
            return {
                'success': True,
                'hosts_scanned': len(scan_results),
                'ecdsa_detected': ecdsa_count,
                'vulnerable_hosts': vulnerable_count,
                'scan_results': scan_results,
                'report': report
            }
            
        except Exception as e:
            error_msg = f"Scanner execution error: {e}"
            print(f" {error_msg}")
            return {'success': False, 'error': error_msg}


def main():
    """CLI interface for ECDSA vulnerability scanner"""
    if len(sys.argv) < 2:
        print("Usage: python ecdsa_vuln_scanner.py <target_host1> [target_host2] ... [--port PORT]")
        print("Example: python ecdsa_vuln_scanner.py google.com github.com --port 443")
        sys.exit(1)
    
    target_hosts = []
    port = 443
    
    # Parse arguments
    i = 1
    while i < len(sys.argv):
        if sys.argv[i] == '--port':
            if i + 1 < len(sys.argv):
                port = int(sys.argv[i + 1])
                i += 2
            else:
                print(" --port requires a port number")
                sys.exit(1)
        else:
            target_hosts.append(sys.argv[i])
            i += 1
    
    if not target_hosts:
        print(" No target hosts specified")
        sys.exit(1)
    
    scanner = ECDSAVulnScanner()
    result = scanner.run(target_hosts, port)
    
    if result['success']:
        print(f"\n[TARGET] Scan completed successfully!")
        print(f"Vulnerable hosts: {result['vulnerable_hosts']}/{result['hosts_scanned']}")
        
        # Print report
        print("\n" + result['report'])
        sys.exit(0)
    else:
        print(f"\n Scan failed: {result.get('error', 'Unknown error')}")
        sys.exit(1)


if __name__ == "__main__":
    main()
