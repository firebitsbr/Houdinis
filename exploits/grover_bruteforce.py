#!/usr/bin/env python3
"""
Houdinis Framework - Grover Brute Force Exploit
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
License: MIT

Implements Grover's algorithm for brute force attacks against
symmetric encryption keys, passwords, and hash preimages.
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
    from qiskit import transpile
    import numpy as np
    QUANTUM_AVAILABLE = True
except ImportError:
    QUANTUM_AVAILABLE = False
    print("  Quantum libraries not available, using classical simulation")

import hashlib
import itertools
import random
import time
from typing import Dict, List, Optional


class GroverBruteForceExploit:
    """Grover's algorithm for brute force attacks"""
    
    def __init__(self):
        self.name = "Grover Brute Force Exploit"
        self.description = "Quantum brute force attack using Grover's algorithm"
        self.author = "Mauro Risonho de Paula Assumpção aka firebitsbr"
        self.difficulty = "Intermediate"
        self.category = "quantum_cryptanalysis"
        
    def info(self) -> Dict:
        """Return exploit information"""
        return {
            'name': self.name,
            'description': self.description,
            'author': self.author,
            'difficulty': self.difficulty,
            'category': self.category,
            'target': 'Symmetric keys, passwords, hash preimages',
            'quantum_algorithm': 'Grover\'s search algorithm',
            'requirements': ['quantum_backend', 'target_hash_or_ciphertext']
        }
    
    def classical_brute_force(self, target_hash: str, hash_type: str, max_length: int) -> Optional[str]:
        """Classical brute force attack for comparison"""
        print(f"[LOADING] Classical brute force attack...")
        
        charset = "abcdefghijklmnopqrstuvwxyz0123456789"
        attempts = 0
        max_attempts = 100000  # Limit for demo
        
        start_time = time.time()
        
        for length in range(1, max_length + 1):
            for candidate in itertools.product(charset, repeat=length):
                candidate_str = ''.join(candidate)
                attempts += 1
                
                # Hash the candidate
                if hash_type.lower() == 'md5':
                    candidate_hash = hashlib.md5(candidate_str.encode()).hexdigest()
                elif hash_type.lower() == 'sha256':
                    candidate_hash = hashlib.sha256(candidate_str.encode()).hexdigest()
                else:
                    candidate_hash = hashlib.sha1(candidate_str.encode()).hexdigest()
                
                if candidate_hash == target_hash:
                    elapsed = time.time() - start_time
                    print(f" Found: '{candidate_str}' after {attempts} attempts in {elapsed:.2f}s")
                    return candidate_str
                
                if attempts >= max_attempts:
                    print(f" Reached maximum attempts ({max_attempts})")
                    return None
        
        print(f" Not found after checking {attempts} combinations")
        return None
    
    def quantum_grover_search(self, target_hash: str, hash_type: str, search_space_bits: int, backend_type: str = 'simulator') -> Optional[str]:
        """Quantum Grover's algorithm search"""
        print(f" Quantum Grover's algorithm search...")
        
        if not QUANTUM_AVAILABLE:
            print(" Quantum libraries not available")
            return None
        
        try:
            from quantum.backend import QuantumBackendManager
            backend_manager = QuantumBackendManager()
            
            backend = backend_manager.get_backend()
            if not backend:
                print(" No quantum backend available")
                return None
            
            # Limit search space for quantum simulation
            n_qubits = min(search_space_bits, 12)  # Limit to prevent simulation issues
            search_space_size = 2 ** n_qubits
            
            print(f"[TARGET] Search space: {search_space_size} possibilities ({n_qubits} qubits)")
            
            # Create Grover circuit
            qc = self._create_grover_circuit(target_hash, hash_type, n_qubits)
            
            # Execute on quantum backend
            transpiled = transpile(qc, backend)
            job = backend.run(transpiled, shots=1024)
            result = job.result()
            counts = result.get_counts()
            
            # Process results
            candidate = self._process_grover_results(counts, target_hash, hash_type, n_qubits)
            
            if candidate:
                print(f" Quantum search found candidate: '{candidate}'")
                return candidate
            else:
                print(" Quantum search failed to find solution")
                return None
                
        except Exception as e:
            print(f" Quantum execution error: {e}")
            return None
    
    def _create_grover_circuit(self, target_hash: str, hash_type: str, n_qubits: int) -> 'QuantumCircuit':
        """Create Grover quantum circuit"""
        qreg = QuantumRegister(n_qubits, 'q')
        creg = ClassicalRegister(n_qubits, 'c')
        qc = QuantumCircuit(qreg, creg)
        
        # Initialize superposition
        qc.h(qreg)
        
        # Calculate optimal number of iterations
        search_space_size = 2 ** n_qubits
        optimal_iterations = int(np.pi * np.sqrt(search_space_size) / 4)
        
        print(f"[LOADING] Applying {optimal_iterations} Grover iterations")
        
        # Apply Grover iterations
        for _ in range(optimal_iterations):
            # Oracle (simplified - marks target state)
            self._apply_oracle(qc, qreg, target_hash, hash_type)
            
            # Diffusion operator
            self._apply_diffusion(qc, qreg)
        
        # Measurement
        qc.measure(qreg, creg)
        
        return qc
    
    def _apply_oracle(self, qc: 'QuantumCircuit', qreg: 'QuantumRegister', target_hash: str, hash_type: str):
        """Apply oracle that marks the target state"""
        # Simplified oracle implementation
        # In a real implementation, this would be a quantum hash function
        
        # For demonstration, we'll use a pattern-based oracle
        target_pattern = sum(int(c, 16) for c in target_hash[:4]) % (2 ** len(qreg))
        
        # Convert target pattern to binary
        target_bits = format(target_pattern, f'0{len(qreg)}b')
        
        # Apply X gates to flip qubits that should be 0 in target state
        for i, bit in enumerate(target_bits):
            if bit == '0':
                qc.x(qreg[i])
        
        # Multi-controlled Z gate (phase flip for target state)
        if len(qreg) > 1:
            qc.mcrz(np.pi, qreg[:-1], qreg[-1])
        else:
            qc.z(qreg[0])
        
        # Flip back the X gates
        for i, bit in enumerate(target_bits):
            if bit == '0':
                qc.x(qreg[i])
    
    def _apply_diffusion(self, qc: 'QuantumCircuit', qreg: 'QuantumRegister'):
        """Apply diffusion operator (inversion about average)"""
        # H gates
        qc.h(qreg)
        
        # X gates
        qc.x(qreg)
        
        # Multi-controlled Z gate
        if len(qreg) > 1:
            qc.mcrz(np.pi, qreg[:-1], qreg[-1])
        else:
            qc.z(qreg[0])
        
        # X gates
        qc.x(qreg)
        
        # H gates
        qc.h(qreg)
    
    def _process_grover_results(self, counts: Dict, target_hash: str, hash_type: str, n_qubits: int) -> Optional[str]:
        """Process Grover algorithm results"""
        # Find most frequent measurement result
        max_count = 0
        best_result = None
        
        for bitstring, count in counts.items():
            if count > max_count:
                max_count = count
                best_result = bitstring
        
        if not best_result:
            return None
        
        # Convert bitstring to candidate string
        candidate_int = int(best_result, 2)
        candidate = self._int_to_string(candidate_int, n_qubits)
        
        # Verify candidate
        if self._verify_candidate(candidate, target_hash, hash_type):
            return candidate
        
        # Try variations around the best result
        for delta in range(-5, 6):
            test_int = (candidate_int + delta) % (2 ** n_qubits)
            test_candidate = self._int_to_string(test_int, n_qubits)
            if self._verify_candidate(test_candidate, target_hash, hash_type):
                return test_candidate
        
        return None
    
    def _int_to_string(self, value: int, max_bits: int) -> str:
        """Convert integer to candidate string"""
        # Simple mapping for demonstration
        charset = "abcdefghijklmnopqrstuvwxyz0123456789"
        result = ""
        
        while value > 0 and len(result) < 8:  # Max 8 characters
            result = charset[value % len(charset)] + result
            value //= len(charset)
        
        return result if result else "a"
    
    def _verify_candidate(self, candidate: str, target_hash: str, hash_type: str) -> bool:
        """Verify if candidate produces target hash"""
        try:
            if hash_type.lower() == 'md5':
                candidate_hash = hashlib.md5(candidate.encode()).hexdigest()
            elif hash_type.lower() == 'sha256':
                candidate_hash = hashlib.sha256(candidate.encode()).hexdigest()
            else:
                candidate_hash = hashlib.sha1(candidate.encode()).hexdigest()
            
            return candidate_hash == target_hash
        except:
            return False
    
    def analyze_target(self, target_hash: str, hash_type: str) -> Dict:
        """Analyze the target for attack feasibility"""
        analysis = {
            'hash_type': hash_type,
            'hash_length': len(target_hash),
            'estimated_keyspace': 'unknown',
            'quantum_advantage': 'unknown',
            'classical_time': 'unknown',
            'quantum_time': 'unknown',
            'feasibility': 'unknown'
        }
        
        # Estimate keyspace based on hash type and typical key lengths
        if hash_type.lower() == 'md5':
            analysis['hash_length'] = 32
            analysis['estimated_keyspace'] = '2^128 (if random key)'
        elif hash_type.lower() == 'sha256':
            analysis['hash_length'] = 64
            analysis['estimated_keyspace'] = '2^256 (if random key)'
        elif hash_type.lower() == 'sha1':
            analysis['hash_length'] = 40
            analysis['estimated_keyspace'] = '2^160 (if random key)'
        
        # Estimate attack times (simplified)
        if len(target_hash) <= 32:  # Assuming shorter passwords
            analysis['classical_time'] = '2^64 operations (years on classical computer)'
            analysis['quantum_time'] = '2^32 operations (Grover speedup)'
            analysis['quantum_advantage'] = 'Quadratic speedup'
            analysis['feasibility'] = 'Potentially feasible with large quantum computer'
        else:
            analysis['classical_time'] = '2^128+ operations (infeasible)'
            analysis['quantum_time'] = '2^64+ operations (still very difficult)'
            analysis['quantum_advantage'] = 'Quadratic speedup, but still challenging'
            analysis['feasibility'] = 'Requires very large fault-tolerant quantum computer'
        
        return analysis
    
    def run(self, target_hash: str, hash_type: str = 'md5', max_length: int = 6, backend_type: str = 'simulator') -> Dict:
        """Run the Grover brute force exploit"""
        try:
            print(f"[TARGET] Grover Brute Force Exploit")
            print(f"=" * 50)
            print(f"Target hash: {target_hash}")
            print(f"Hash type: {hash_type.upper()}")
            print(f"Max length: {max_length}")
            
            # Analyze target
            analysis = self.analyze_target(target_hash, hash_type)
            
            print(f"\n Target Analysis:")
            print(f"   -  Hash type: {analysis['hash_type'].upper()}")
            print(f"   -  Estimated keyspace: {analysis['estimated_keyspace']}")
            print(f"   -  Quantum advantage: {analysis['quantum_advantage']}")
            print(f"   -  Feasibility: {analysis['feasibility']}")
            
            # Attempt quantum search first
            search_space_bits = min(max_length * 5, 12)  # Rough estimate, limited for simulation
            
            print(f"\n Attempting Grover quantum search...")
            quantum_result = self.quantum_grover_search(target_hash, hash_type, search_space_bits, backend_type)
            
            if quantum_result:
                # Verify quantum result
                if self._verify_candidate(quantum_result, target_hash, hash_type):
                    print(f" Quantum attack successful!")
                    return {
                        'success': True,
                        'method': 'quantum_grover',
                        'result': quantum_result,
                        'target_hash': target_hash,
                        'hash_type': hash_type,
                        'analysis': analysis
                    }
            
            # Fallback to classical brute force
            print(f"\n[LOADING] Attempting classical brute force (limited search)...")
            classical_result = self.classical_brute_force(target_hash, hash_type, max_length)
            
            if classical_result:
                print(f" Classical attack successful!")
                return {
                    'success': True,
                    'method': 'classical_brute_force',
                    'result': classical_result,
                    'target_hash': target_hash,
                    'hash_type': hash_type,
                    'analysis': analysis
                }
            else:
                print(f" Both quantum and classical attacks failed")
                return {
                    'success': False,
                    'error': 'Target not found in search space',
                    'analysis': analysis
                }
                
        except Exception as e:
            error_msg = f"Exploit execution error: {e}"
            print(f" {error_msg}")
            return {'success': False, 'error': error_msg}


def main():
    """CLI interface for Grover brute force exploit"""
    if len(sys.argv) < 2:
        print("Usage: python grover_bruteforce.py <target_hash> [hash_type] [max_length]")
        print("Example: python grover_bruteforce.py 5d41402abc4b2a76b9719d911017c592 md5 6")
        print("Hash types: md5, sha1, sha256")
        sys.exit(1)
    
    target_hash = sys.argv[1]
    hash_type = sys.argv[2] if len(sys.argv) > 2 else 'md5'
    max_length = int(sys.argv[3]) if len(sys.argv) > 3 else 6
    
    exploit = GroverBruteForceExploit()
    result = exploit.run(target_hash, hash_type, max_length)
    
    if result['success']:
        print(f"\n[TARGET] Exploit completed successfully!")
        print(f"Found: {result['result']}")
        sys.exit(0)
    else:
        print(f"\n Exploit failed: {result.get('error', 'Unknown error')}")
        sys.exit(1)


if __name__ == "__main__":
    main()
