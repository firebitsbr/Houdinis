"""
Multi-Backend Quantum Circuit Benchmarker for Houdinis

Demonstrates and benchmarks quantum algorithms across multiple backends:
- IBM Quantum Experience
- NVIDIA cuQuantum
- Amazon Braket
- Azure Quantum
- Google Cirq

MIT License

Copyright (c) 2025 Mauro Risonho de Paula Assumpção aka firebitsbr
"""

import sys
import time
import json
import random
from pathlib import Path
from typing import Dict, Any, List, Optional
from datetime import datetime

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

try:
    from qiskit import QuantumCircuit
    from qiskit.circuit.random import random_circuit
    QISKIT_AVAILABLE = True
except ImportError:
    QISKIT_AVAILABLE = False

from core.modules import BaseModule


class MultiBackendBenchmark(BaseModule):
    """
    Multi-backend quantum benchmarking module.
    Tests and compares performance across different quantum computing platforms.
    """
    
    def __init__(self):
        super().__init__()
        self.info = {
            'name': 'multi_backend_benchmark',
            'description': 'Benchmark quantum algorithms across multiple backends',
            'author': 'Mauro Risonho de Paula Assumpção aka firebitsbr',
            'version': '1.0.0',
            'category': 'exploit'
        }
        
        self.options = {
            'ALGORITHM': {
                'value': 'shor',
                'required': True,
                'description': 'Quantum algorithm to benchmark',
                'choices': ['shor', 'grover', 'qft', 'vqe', 'random_circuit', 'bell_state']
            },
            'TARGET_NUMBER': {
                'value': '15',
                'required': False,
                'description': 'Target number for Shor algorithm'
            },
            'SEARCH_SPACE': {
                'value': '16',
                'required': False,
                'description': 'Search space size for Grover algorithm (power of 2)'
            },
            'QUBITS': {
                'value': '4',
                'required': True,
                'description': 'Number of qubits for the circuit'
            },
            'CIRCUIT_DEPTH': {
                'value': '10',
                'required': False,
                'description': 'Circuit depth for random circuits'
            },
            'BACKENDS': {
                'value': 'all',
                'required': False,
                'description': 'Backends to test (comma-separated or "all")'
            },
            'SHOTS': {
                'value': '1024',
                'required': False,
                'description': 'Number of measurement shots'
            },
            'RUNS': {
                'value': '3',
                'required': False,
                'description': 'Number of benchmark runs per backend'
            },
            'TIMEOUT': {
                'value': '300',
                'required': False,
                'description': 'Timeout per backend in seconds'
            },
            'SAVE_RESULTS': {
                'value': 'true',
                'required': False,
                'description': 'Save benchmark results to file'
            }
        }
        
        self.benchmark_results = {}
    
    def print_info(self, message: str):
        """Print info message (compatibility with BaseModule)."""
        print(f"[INFO] {message}")
    
    def print_success(self, message: str):
        """Print success message (compatibility with BaseModule)."""
        print(f"[SUCCESS] {message}")
    
    def print_error(self, message: str):
        """Print error message (compatibility with BaseModule)."""
        print(f"[ERROR] {message}")
    
    def print_result(self, message: str):
        """Print result message (compatibility with BaseModule)."""
        print(f"[RESULT] {message}")
    
    def print_line(self):
        """Print separator line (compatibility with BaseModule)."""
        print("-" * 60)
    
    def run(self) -> Dict[str, Any]:
        """Execute the multi-backend benchmark."""
        if not QISKIT_AVAILABLE:
            return {
                'success': False,
                'error': 'Qiskit not available. Install with: pip install qiskit'
            }
        
        algorithm = self.options['ALGORITHM']['value']
        qubits = int(self.options['QUBITS']['value'])
        
        # Generate quantum circuit based on algorithm
        circuit = self._generate_circuit(algorithm, qubits)
        if circuit is None:
            return {
                'success': False,
                'error': f'Failed to generate circuit for algorithm: {algorithm}'
            }
        
        self.print_info("=== Multi-Backend Quantum Benchmark ===")
        self.print_info(f"Algorithm: {algorithm}")
        self.print_info(f"Qubits: {qubits}")
        self.print_info(f"Circuit depth: {circuit.depth()}")
        self.print_line()
        
        # Get available backends
        backends_to_test = self._get_backends_to_test()
        
        if not backends_to_test:
            return {
                'success': False,
                'error': 'No backends available for testing'
            }
        
        self.print_info(f"Testing on {len(backends_to_test)} backends...")
        self.print_line()
        
        # Run benchmarks
        results = {}
        for backend_name in backends_to_test:
            self.print_info(f"Testing backend: {backend_name}")
            
            backend_result = self._benchmark_backend(circuit, backend_name)
            results[backend_name] = backend_result
            
            if backend_result['success']:
                avg_time = backend_result.get('average_time', 0)
                self.print_success(f"[PASS] {backend_name}: {avg_time:.3f}s average")
            else:
                error = backend_result.get('error', 'Unknown error')
                self.print_error(f"[FAIL] {backend_name}: {error}")
        
        # Analyze results
        analysis = self._analyze_results(results)
        
        # Display summary
        self._display_summary(analysis)
        
        # Save results if requested
        if self.options['SAVE_RESULTS']['value'].lower() == 'true':
            self._save_results(results, analysis)
        
        return {
            'success': True,
            'algorithm': algorithm,
            'qubits': qubits,
            'backends_tested': len(backends_to_test),
            'results': results,
            'analysis': analysis
        }
    
    def _generate_circuit(self, algorithm: str, qubits: int) -> Optional['QuantumCircuit']:
        """Generate quantum circuit based on algorithm type."""
        try:
            if algorithm == 'shor':
                return self._create_shor_circuit(qubits)
            elif algorithm == 'grover':
                return self._create_grover_circuit(qubits)
            elif algorithm == 'qft':
                return self._create_qft_circuit(qubits)
            elif algorithm == 'vqe':
                return self._create_vqe_circuit(qubits)
            elif algorithm == 'random_circuit':
                depth = int(self.options['CIRCUIT_DEPTH']['value'])
                if QISKIT_AVAILABLE:
                    return random_circuit(qubits, depth, measure=True)
                else:
                    return self._create_bell_state_circuit()
            elif algorithm == 'bell_state':
                return self._create_bell_state_circuit()
            else:
                return None
                
        except Exception as e:
            self.print_error(f"Error generating {algorithm} circuit: {e}")
            return None
    
    def _create_shor_circuit(self, qubits: int) -> 'QuantumCircuit':
        """Create a simplified Shor's algorithm circuit."""
        circuit = QuantumCircuit(qubits)
        
        # Simplified Shor's algorithm demonstration
        # Initialize superposition
        for i in range(qubits // 2):
            circuit.h(i)
        
        # Controlled operations (simplified)
        for i in range(qubits // 2):
            for j in range(qubits // 2, qubits):
                circuit.cx(i, j)
        
        # QFT inverse (simplified)
        for i in range(qubits // 2):
            circuit.h(i)
        
        circuit.measure_all()
        return circuit
    
    def _create_grover_circuit(self, qubits: int) -> 'QuantumCircuit':
        """Create Grover's algorithm circuit."""
        circuit = QuantumCircuit(qubits)
        
        # Initialize superposition
        for i in range(qubits):
            circuit.h(i)
        
        # Oracle (mark state |11...1>)
        if qubits > 1:
            circuit.mct(list(range(qubits - 1)), qubits - 1)
        
        # Diffusion operator
        for i in range(qubits):
            circuit.h(i)
            circuit.x(i)
        
        if qubits > 1:
            circuit.mct(list(range(qubits - 1)), qubits - 1)
        
        for i in range(qubits):
            circuit.x(i)
            circuit.h(i)
        
        circuit.measure_all()
        return circuit
    
    def _create_qft_circuit(self, qubits: int) -> 'QuantumCircuit':
        """Create Quantum Fourier Transform circuit."""
        circuit = QuantumCircuit(qubits)
        
        # Initialize with some state
        for i in range(min(qubits, 3)):
            circuit.x(i)
        
        # QFT implementation
        for i in range(qubits):
            circuit.h(i)
            for j in range(i + 1, qubits):
                circuit.cp(2 * 3.14159 / (2 ** (j - i + 1)), j, i)
        
        # Swap qubits
        for i in range(qubits // 2):
            circuit.swap(i, qubits - 1 - i)
        
        circuit.measure_all()
        return circuit
    
    def _create_vqe_circuit(self, qubits: int) -> 'QuantumCircuit':
        """Create Variational Quantum Eigensolver circuit."""
        circuit = QuantumCircuit(qubits)
        
        # Parameterized ansatz
        for i in range(qubits):
            circuit.ry(0.5, i)  # Simplified: using fixed parameters
        
        for i in range(qubits - 1):
            circuit.cx(i, i + 1)
        
        for i in range(qubits):
            circuit.ry(0.3, i)
        
        circuit.measure_all()
        return circuit
    
    def _create_bell_state_circuit(self) -> 'QuantumCircuit':
        """Create Bell state circuit."""
        circuit = QuantumCircuit(2)
        circuit.h(0)
        circuit.cx(0, 1)
        circuit.measure_all()
        return circuit
    
    def _get_backends_to_test(self) -> List[str]:
        """Get list of backends to test."""
        try:
            # Simulate available backends for demonstration
            all_backends = [
                'aer_simulator',
                'qasm_simulator', 
                'ibmq_qasm_simulator',
                'ibmq_santiago',
                'nvidia_cuquantum',
                'braket_sv1',
                'braket_tn1',
                'azure_quantinuum',
                'google_cirq_simulator'
            ]
            
            backends_option = self.options['BACKENDS']['value']
            
            if backends_option.lower() == 'all':
                return all_backends
            else:
                # Parse comma-separated list
                requested = [b.strip() for b in backends_option.split(',') if b.strip()]
                return [b for b in requested if b in all_backends]
                
        except Exception as e:
            self.print_error(f"Error getting backends: {e}")
            return ['aer_simulator']  # Default fallback
    
    def _benchmark_backend(self, circuit: 'QuantumCircuit', backend_name: str) -> Dict[str, Any]:
        """Benchmark a specific backend."""
        runs = int(self.options['RUNS']['value'])
        shots = int(self.options['SHOTS']['value'])
        timeout = int(self.options['TIMEOUT']['value'])
        
        execution_times = []
        errors = []
        
        for run in range(runs):
            try:
                start_time = time.time()
                
                # Execute circuit (simulated execution for now)
                result = self._simulate_execution(circuit, backend_name, shots, timeout)
                
                execution_time = time.time() - start_time
                
                if result['success']:
                    execution_times.append(execution_time)
                else:
                    errors.append(result.get('error', 'Unknown error'))
                    
            except Exception as e:
                errors.append(str(e))
        
        if execution_times:
            return {
                'success': True,
                'runs': len(execution_times),
                'execution_times': execution_times,
                'average_time': sum(execution_times) / len(execution_times),
                'min_time': min(execution_times),
                'max_time': max(execution_times),
                'errors': errors
            }
        else:
            return {
                'success': False,
                'error': f"All runs failed. Errors: {errors}",
                'runs': runs,
                'execution_times': [],
                'errors': errors
            }
    
    def _simulate_execution(self, circuit: 'QuantumCircuit', backend_name: str, 
                           shots: int, timeout: int) -> Dict[str, Any]:
        """Simulate circuit execution on backend."""
        # This is a simulation - in real implementation would use actual backends
        
        # Simulate different execution times based on backend type
        if 'aer' in backend_name or 'local' in backend_name:
            base_time = 0.1  # Fast local simulation
        elif 'nvidia' in backend_name or 'cuquantum' in backend_name:
            base_time = 0.05  # Very fast GPU
        elif 'ibmq' in backend_name:
            base_time = 5.0  # Slow real hardware with queue
        elif 'braket' in backend_name:
            base_time = 1.0  # Cloud simulation
        elif 'azure' in backend_name:
            base_time = 1.5  # Azure cloud
        elif 'cirq' in backend_name or 'google' in backend_name:
            base_time = 0.8  # Google simulation
        else:
            base_time = 2.0  # Default
        
        # Add circuit complexity factor
        complexity_factor = circuit.depth() * circuit.num_qubits / 100.0
        simulated_time = base_time + complexity_factor
        
        # Simulate execution delay
        time.sleep(min(simulated_time, 0.5))  # Cap at 0.5s for demo
        
        # Simulate occasional failures
        if random.random() < 0.1:  # 10% failure rate
            return {
                'success': False,
                'error': f'Simulated execution error on {backend_name}'
            }
        
        return {
            'success': True,
            'counts': {'00': shots // 2, '11': shots // 2},  # Simulated results
            'backend': backend_name
        }
    
    def _analyze_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze benchmark results."""
        successful_backends = {k: v for k, v in results.items() if v.get('success', False)}
        
        if not successful_backends:
            return {
                'fastest_backend': None,
                'slowest_backend': None,
                'average_time': 0,
                'success_rate': 0,
                'backend_ranking': []
            }
        
        # Find fastest and slowest
        sorted_backends = sorted(successful_backends.items(), 
                               key=lambda x: x[1].get('average_time', float('inf')))
        
        fastest = sorted_backends[0]
        slowest = sorted_backends[-1]
        
        # Calculate overall metrics
        all_times = []
        for result in successful_backends.values():
            all_times.extend(result.get('execution_times', []))
        
        avg_time = sum(all_times) / len(all_times) if all_times else 0
        success_rate = len(successful_backends) / len(results) if results else 0
        
        # Create ranking
        ranking = [(name, data['average_time']) for name, data in sorted_backends]
        
        return {
            'fastest_backend': fastest[0],
            'fastest_time': fastest[1].get('average_time', 0),
            'slowest_backend': slowest[0],
            'slowest_time': slowest[1].get('average_time', 0),
            'average_time': avg_time,
            'success_rate': success_rate,
            'backend_ranking': ranking,
            'total_executions': len(all_times)
        }
    
    def _display_summary(self, analysis: Dict[str, Any]) -> None:
        """Display benchmark summary."""
        self.print_line()
        self.print_info("=== Benchmark Summary ===")
        
        if analysis['fastest_backend']:
            self.print_success(f"[WINNER] Fastest: {analysis['fastest_backend']} ({analysis['fastest_time']:.3f}s)")
            self.print_info(f" Slowest: {analysis['slowest_backend']} ({analysis['slowest_time']:.3f}s)")
            self.print_info(f"[STATS] Overall average: {analysis['average_time']:.3f}s")
            self.print_info(f" Success rate: {analysis['success_rate']:.1%}")
            self.print_info(f"[NUMERIC] Total executions: {analysis['total_executions']}")
            
            self.print_line()
            self.print_info("Backend Performance Ranking:")
            for i, (backend, time) in enumerate(analysis['backend_ranking'], 1):
                self.print_result(f"  {i}. {backend}: {time:.3f}s")
        else:
            self.print_error(" No successful executions")
    
    def _save_results(self, results: Dict[str, Any], analysis: Dict[str, Any]) -> None:
        """Save benchmark results to file."""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"quantum_benchmark_{timestamp}.json"
            
            output = {
                'timestamp': timestamp,
                'algorithm': self.options['ALGORITHM']['value'],
                'qubits': int(self.options['QUBITS']['value']),
                'shots': int(self.options['SHOTS']['value']),
                'runs': int(self.options['RUNS']['value']),
                'results': results,
                'analysis': analysis
            }
            
            with open(filename, 'w') as f:
                json.dump(output, f, indent=2, default=str)
            
            self.print_success(f"[FOLDER] Results saved to: {filename}")
            
        except Exception as e:
            self.print_error(f"Error saving results: {e}")


# Module instance for the framework
module = MultiBackendBenchmark()
