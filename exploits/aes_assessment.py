#!/usr/bin/env python3
"""
Houdinis Framework - AES Quantum Assessment
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
License: MIT

Assesses AES implementations for quantum vulnerabilities
and Grover's algorithm impact on symmetric encryption.
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import hashlib
import hmac
import struct
import random
import time
from typing import Dict, List, Optional
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad


class AESQuantumAssessment:
    """AES quantum vulnerability assessment tool"""

    def __init__(self):
        """TODO: Add description for __init__"""
        self.name = "AES Quantum Assessment"
        self.description = "Assess AES implementations for quantum vulnerabilities"
        self.author = "Mauro Risonho de Paula Assumpção aka firebitsbr"
        self.difficulty = "Intermediate"
        self.category = "quantum_assessment"

    def info(self) -> Dict:
        """Return assessment tool information"""
        return {
            'name': self.name,
            'description': self.description,
            'author': self.author,
            'difficulty': self.difficulty,
            'category': self.category,
            'target': 'AES symmetric encryption implementations',
            'quantum_threat': 'Grover\'s algorithm reduces effective key length by half',
            'requirements': ['aes_encrypted_data', 'key_derivation_analysis']
        }

    def get_aes_security_levels(self) -> Dict:
        """Get AES security levels in classical vs quantum scenarios"""
        return {
            'AES-128': {
                'key_size': 128,
                'classical_security': 128,
                'quantum_security': 64,  # Grover's algorithm halves security
                'break_timeline': '2040-2050',
                'risk_level': 'MEDIUM',
                'status': 'Quantum-vulnerable',
                'recommendation': 'Upgrade to AES-256 or post-quantum'
            },
            'AES-192': {
                'key_size': 192,
                'classical_security': 192,
                'quantum_security': 96,
                'break_timeline': '2050-2060',
                'risk_level': 'LOW',
                'status': 'Quantum-resistant (medium-term)',
                'recommendation': 'Monitor developments, plan migration'
            },
            'AES-256': {
                'key_size': 256,
                'classical_security': 256,
                'quantum_security': 128,
                'break_timeline': '2060+',
                'risk_level': 'LOW',
                'status': 'Quantum-resistant',
                'recommendation': 'Acceptable for medium-term use'
            }
        }

    def analyze_aes_mode(self, mode: str) -> Dict:
        """Analyze AES mode of operation for quantum implications"""
        modes_analysis = {
            'ECB': {
                'security': 'WEAK',
                'quantum_impact': 'HIGH',
                'vulnerabilities': [
                    'Pattern exposure in ciphertext',
                    'Parallel Grover attacks possible',
                    'No semantic security'
                ],
                'recommendation': 'Never use ECB mode'
            },
            'CBC': {
                'security': 'MODERATE',
                'quantum_impact': 'MEDIUM',
                'vulnerabilities': [
                    'IV reuse attacks',
                    'Padding oracle attacks',
                    'Sequential decryption under quantum attack'
                ],
                'recommendation': 'Use with proper IV generation'
            },
            'CTR': {
                'security': 'GOOD',
                'quantum_impact': 'MEDIUM',
                'vulnerabilities': [
                    'Nonce reuse catastrophic',
                    'Parallel Grover attacks on keystream'
                ],
                'recommendation': 'Ensure unique nonces'
            },
            'GCM': {
                'security': 'EXCELLENT',
                'quantum_impact': 'LOW',
                'vulnerabilities': [
                    'Nonce reuse breaks authentication',
                    'Quantum attacks on GHASH'
                ],
                'recommendation': 'Preferred mode for new implementations'
            },
            'CCM': {
                'security': 'GOOD',
                'quantum_impact': 'LOW',
                'vulnerabilities': [
                    'Nonce management critical'
                ],
                'recommendation': 'Good alternative to GCM'
            }
        }

        return modes_analysis.get(mode.upper(), {
            'security': 'UNKNOWN',
            'quantum_impact': 'UNKNOWN',
            'vulnerabilities': ['Unknown mode'],
            'recommendation': 'Use standard modes like GCM'
        })

    def simulate_grover_attack(self, key_size: int, known_plaintext: bytes = None) -> Dict:
        """Simulate Grover's algorithm attack against AES key"""
        print(f" Simulating Grover's algorithm attack on AES-{key_size}")

        # Calculate attack complexity
        classical_operations = 2 ** key_size
        quantum_operations = 2 ** (key_size // 2)  # Grover's quadratic speedup

        # Estimate attack times (very rough estimates)
        classical_years = classical_operations / (10**12 * 365 * 24 * 3600)  # Assuming 1 THz
        quantum_seconds = quantum_operations / (10**6)  # Assuming 1 MHz quantum computer

        attack_analysis = {
            'key_size': key_size,
            'classical_operations': classical_operations,
            'quantum_operations': quantum_operations,
            'speedup_factor': classical_operations / quantum_operations,
            'classical_time_years': classical_years,
            'quantum_time_seconds': quantum_seconds,
            'feasibility': 'INFEASIBLE',
            'quantum_computer_requirements': 'Unknown'
        }

        if key_size == 128:
            attack_analysis['feasibility'] = 'THEORETICALLY_POSSIBLE'
            attack_analysis['quantum_computer_requirements'] = '~3000 logical qubits'
        elif key_size == 192:
            attack_analysis['feasibility'] = 'VERY_DIFFICULT'
            attack_analysis['quantum_computer_requirements'] = '~4500 logical qubits'
        elif key_size == 256:
            attack_analysis['feasibility'] = 'EXTREMELY_DIFFICULT'
            attack_analysis['quantum_computer_requirements'] = '~6000 logical qubits'

        print(f"   -  Classical operations: 2^{key_size} = {classical_operations:.2e}")
        print(f"   -  Quantum operations: 2^{key_size//2} = {quantum_operations:.2e}")
        print(f"   -  Speedup factor: {attack_analysis['speedup_factor']:.2e}")
        print(f"   -  Feasibility: {attack_analysis['feasibility']}")

        return attack_analysis

    def analyze_key_derivation(self, password: str, salt: bytes = None) -> Dict:
        """Analyze key derivation function quantum resistance"""
        if salt is None:
            salt = get_random_bytes(16)

        print(f" Analyzing key derivation for password: '{password}'")

        # Test different KDF methods
        kdf_analysis = {}

        # PBKDF2
        start_time = time.time()
        iterations = 100000
        pbkdf2_key = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, iterations)
        pbkdf2_time = time.time() - start_time

        kdf_analysis['PBKDF2'] = {
            'iterations': iterations,
            'time_seconds': pbkdf2_time,
            'quantum_resistance': 'MODERATE',
            'grover_impact': 'Reduces effective security by half',
            'recommendation': 'Increase iterations for quantum era'
        }

        # Simple hash (weak)
        start_time = time.time()
        simple_key = hashlib.sha256(password.encode() + salt).digest()
        simple_time = time.time() - start_time

        kdf_analysis['Simple_Hash'] = {
            'iterations': 1,
            'time_seconds': simple_time,
            'quantum_resistance': 'WEAK',
            'grover_impact': 'Direct Grover attack on password space',
            'recommendation': 'Never use for key derivation'
        }

        return kdf_analysis

    def test_aes_implementation(self, key_size: int, mode: str, plaintext: bytes) -> Dict:
        """Test specific AES implementation for quantum vulnerabilities"""
        print(f" Testing AES-{key_size} in {mode} mode")

        try:
            # Generate random key
            key = get_random_bytes(key_size // 8)

            # Test encryption/decryption
            if mode.upper() == 'GCM':
                cipher = AES.new(key, AES.MODE_GCM)
                ciphertext, tag = cipher.encrypt_and_digest(plaintext)
                nonce = cipher.nonce

                # Decrypt
                decipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
                decrypted = decipher.decrypt_and_verify(ciphertext, tag)

            elif mode.upper() == 'CBC':
                iv = get_random_bytes(16)
                cipher = AES.new(key, AES.MODE_CBC, iv)
                padded_plaintext = pad(plaintext, AES.block_size)
                ciphertext = cipher.encrypt(padded_plaintext)

                # Decrypt
                decipher = AES.new(key, AES.MODE_CBC, iv)
                decrypted = unpad(decipher.decrypt(ciphertext), AES.block_size)

            else:
                return {'error': f'Unsupported mode: {mode}'}

            # Verify decryption
            success = decrypted == plaintext

            # Get security analysis
            security_info = self.get_aes_security_levels().get(f'AES-{key_size}', {})
            mode_info = self.analyze_aes_mode(mode)

            result = {
                'key_size': key_size,
                'mode': mode,
                'encryption_success': success,
                'ciphertext_size': len(ciphertext),
                'security_analysis': security_info,
                'mode_analysis': mode_info,
                'quantum_assessment': self.simulate_grover_attack(key_size)
            }

            print(f"   -  Encryption: {' Success' if success else ' Failed'}")
# TODO: Consider breaking this long line (length: 107)
            print(f"   -  Quantum security level: {security_info.get('quantum_security', 'Unknown')} bits")
            print(f"   -  Risk level: {security_info.get('risk_level', 'Unknown')}")

            return result

        except Exception as e:
            return {'error': f'Test failed: {e}'}

    def comprehensive_aes_assessment(self, test_data: bytes = None) -> Dict:
        """Perform comprehensive AES quantum assessment"""
        if test_data is None:
            test_data = b"Houdinis test data for AES assessment - " * 3

        print(f" Comprehensive AES Quantum Assessment")
        print(f"=" * 50)

        assessment_results = {
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'test_data_size': len(test_data),
            'aes_variants': {},
            'overall_recommendations': [],
            'quantum_readiness_score': 0.0
        }

        # Test different AES configurations
        configurations = [
            (128, 'CBC'),
            (128, 'GCM'),
            (192, 'CBC'),
            (192, 'GCM'),
            (256, 'CBC'),
            (256, 'GCM')
        ]

        total_score = 0
        for key_size, mode in configurations:
            print(f"\n Testing AES-{key_size} {mode}")
            result = self.test_aes_implementation(key_size, mode, test_data)

            if 'error' not in result:
                assessment_results['aes_variants'][f'AES-{key_size}-{mode}'] = result

                # Calculate score based on quantum resistance
                variant_score = 0
                if key_size >= 256:
                    variant_score += 4
                elif key_size >= 192:
                    variant_score += 2
                else:
                    variant_score += 1

                if mode.upper() == 'GCM':
                    variant_score += 2
                elif mode.upper() == 'CBC':
                    variant_score += 1

                total_score += variant_score

        # Calculate overall quantum readiness score
        max_possible_score = len(configurations) * 6  # Max score per configuration
        assessment_results['quantum_readiness_score'] = (total_score / max_possible_score) * 100

        # Generate recommendations
        if assessment_results['quantum_readiness_score'] < 50:
            assessment_results['overall_recommendations'] = [
                'CRITICAL: Upgrade to AES-256 immediately',
                'Use authenticated encryption modes (GCM)',
                'Implement post-quantum key exchange',
                'Plan migration to post-quantum symmetric crypto'
            ]
        elif assessment_results['quantum_readiness_score'] < 80:
            assessment_results['overall_recommendations'] = [
                'Upgrade AES-128 implementations to AES-256',
                'Prefer GCM mode over CBC',
                'Monitor post-quantum cryptography standards',
                'Implement crypto-agility'
            ]
        else:
            assessment_results['overall_recommendations'] = [
                'Current AES implementations are quantum-resistant',
                'Continue monitoring quantum developments',
                'Plan for eventual post-quantum migration',
                'Maintain crypto-agility'
            ]

        return assessment_results

    def generate_assessment_report(self, assessment_results: Dict) -> str:
        """Generate detailed assessment report"""
        report = f"""
[SECURITY] AES QUANTUM VULNERABILITY ASSESSMENT REPORT
===============================================

 ASSESSMENT SUMMARY:
   -  Timestamp: {assessment_results.get('timestamp', 'Unknown')}
   -  Test data size: {assessment_results.get('test_data_size', 0)} bytes
   -  Quantum readiness score: {assessment_results.get('quantum_readiness_score', 0):.1f}%

 AES VARIANT ANALYSIS:
"""

        for variant, results in assessment_results.get('aes_variants', {}).items():
            security = results.get('security_analysis', {})
            quantum_assessment = results.get('quantum_assessment', {})

            report += f"""
  {variant}:
     -  Classical security: {security.get('classical_security', 'Unknown')} bits
     -  Quantum security: {security.get('quantum_security', 'Unknown')} bits
     -  Risk level: {security.get('risk_level', 'Unknown')}
     -  Break timeline: {security.get('break_timeline', 'Unknown')}
     -  Grover operations needed: 2^{quantum_assessment.get('key_size', 0)//2}
     -  Feasibility: {quantum_assessment.get('feasibility', 'Unknown')}
"""

        report += f"""
[TARGET] RECOMMENDATIONS:
"""
        for rec in assessment_results.get('overall_recommendations', []):
            report += f"   -  {rec}\n"

        report += f"""
 QUANTUM THREAT ANALYSIS:
   -  AES-128: Reduced to 64-bit effective security (vulnerable by 2040-2050)
   -  AES-192: Reduced to 96-bit effective security (secure until 2050-2060)
   -  AES-256: Reduced to 128-bit effective security (secure beyond 2060)

  GROVER'S ALGORITHM IMPACT:
   -  Quadratic speedup against symmetric encryption
   -  Effectively halves key length security
   -  Requires large fault-tolerant quantum computers
   -  Timeline depends on quantum hardware development

  MITIGATION STRATEGIES:
  1. Upgrade AES-128 to AES-256 immediately
  2. Use authenticated encryption modes (GCM/CCM)
  3. Implement strong key derivation functions
  4. Plan migration to post-quantum symmetric algorithms
  5. Maintain crypto-agility for rapid algorithm updates

[LEGAL]  LEGAL NOTICE:
This assessment is for authorized security testing only.
Results should be used to improve cryptographic security.
"""

        return report

    def run(self, test_mode: str = 'comprehensive', key_size: int = None, mode: str = None) -> Dict:
        """Run AES quantum assessment"""
        try:
            print(f"[SECURITY] AES Quantum Assessment Tool")
            print(f"=" * 50)

            if test_mode == 'comprehensive':
                # Comprehensive assessment
                results = self.comprehensive_aes_assessment()
                report = self.generate_assessment_report(results)

                print(f"\n Assessment Complete!")
                print(f"   -  Quantum readiness score: {results['quantum_readiness_score']:.1f}%")
                print(f"   -  Variants tested: {len(results['aes_variants'])}")

                return {
                    'success': True,
                    'mode': 'comprehensive',
                    'results': results,
                    'report': report
                }

            elif test_mode == 'single' and key_size and mode:
                # Single variant test
                test_data = b"Test data for AES quantum assessment"
                result = self.test_aes_implementation(key_size, mode, test_data)

                if 'error' in result:
                    return {'success': False, 'error': result['error']}

                print(f"\n[TARGET] Single variant test complete!")
                return {
                    'success': True,
                    'mode': 'single',
                    'result': result
                }
            else:
                return {
                    'success': False,
                    'error': 'Invalid test mode or missing parameters'
                }

        except Exception as e:
            error_msg = f"Assessment error: {e}"
            print(f" {error_msg}")
            return {'success': False, 'error': error_msg}


def main():
    """CLI interface for AES quantum assessment"""
    if len(sys.argv) < 2:
        print("Usage: python aes_assessment.py <mode> [options]")
        print("Modes:")
        print("  comprehensive - Full AES quantum assessment")
        print("  single <key_size> <mode> - Test specific AES variant")
        print("Examples:")
        print("  python aes_assessment.py comprehensive")
        print("  python aes_assessment.py single 256 GCM")
        sys.exit(1)

    test_mode = sys.argv[1]

    assessment = AESQuantumAssessment()

    if test_mode == 'comprehensive':
        result = assessment.run('comprehensive')
    elif test_mode == 'single' and len(sys.argv) == 4:
        key_size = int(sys.argv[2])
        mode = sys.argv[3]
        result = assessment.run('single', key_size, mode)
    else:
        print(" Invalid arguments")
        sys.exit(1)

    if result['success']:
        print(f"\n[TARGET] Assessment completed successfully!")

        if 'report' in result:
            print("\n" + result['report'])

        sys.exit(0)
    else:
        print(f"\n Assessment failed: {result.get('error', 'Unknown error')}")
        sys.exit(1)


if __name__ == "__main__":
    main()
