#!/usr/bin/env python3
"""
Quantum Network Reconnaissance
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
License: MIT

Advanced network reconnaissance with quantum cryptography focus
"""

import sys
import socket
import struct
import ssl
import threading
import time
import argparse
import json
import subprocess
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Dict, List, Optional, Tuple, Any

try:
    from qiskit import QuantumCircuit, transpile
    from qiskit.providers.aer import AerSimulator
    import numpy as np
    QISKIT_AVAILABLE = True
except ImportError:
    QISKIT_AVAILABLE = False

try:
    import scapy.all as scapy
    from scapy.layers.inet import IP, TCP, UDP, ICMP
    from scapy.layers.l2 import ARP, Ether
    SCAPY_AVAILABLE = True
except ImportError:
    SCAPY_AVAILABLE = False

try:
    import nmap
    NMAP_AVAILABLE = True
except ImportError:
    NMAP_AVAILABLE = False


class QuantumNetworkRecon:
    """Quantum-focused Network Reconnaissance Tool"""

    def __init__(self):
        """TODO: Add description for __init__"""
        self.quantum_relevant_ports = {
            22: {'service': 'SSH', 'crypto': 'RSA/ECDSA host keys, DH key exchange'},
            25: {'service': 'SMTP', 'crypto': 'STARTTLS with RSA/ECDSA certificates'},
            53: {'service': 'DNS', 'crypto': 'DNSSEC with RSA/ECDSA signatures'},
            80: {'service': 'HTTP', 'crypto': 'Potential redirect to HTTPS'},
            110: {'service': 'POP3', 'crypto': 'STARTTLS with certificates'},
            143: {'service': 'IMAP', 'crypto': 'STARTTLS with certificates'},
            443: {'service': 'HTTPS', 'crypto': 'TLS with RSA/ECDSA certificates'},
            465: {'service': 'SMTPS', 'crypto': 'TLS with certificates'},
            500: {'service': 'IKE', 'crypto': 'IPSec key exchange, DH groups'},
            587: {'service': 'SMTP-SUB', 'crypto': 'STARTTLS with certificates'},
            636: {'service': 'LDAPS', 'crypto': 'TLS with certificates'},
            993: {'service': 'IMAPS', 'crypto': 'TLS with certificates'},
            995: {'service': 'POP3S', 'crypto': 'TLS with certificates'},
            1723: {'service': 'PPTP', 'crypto': 'MPPE encryption'},
            1812: {'service': 'RADIUS', 'crypto': 'Shared secret authentication'},
            4500: {'service': 'IPSec NAT-T', 'crypto': 'IPSec key exchange'},
            5060: {'service': 'SIP', 'crypto': 'TLS-SIP, SRTP'},
            5061: {'service': 'SIPS', 'crypto': 'TLS with certificates'},
            8080: {'service': 'HTTP-ALT', 'crypto': 'Potential HTTPS'},
            8443: {'service': 'HTTPS-ALT', 'crypto': 'TLS with certificates'}
        }

        self.vulnerability_indicators = {
            'weak_ssl_versions': ['SSLv2', 'SSLv3', 'TLSv1.0', 'TLSv1.1'],
            'weak_ciphers': ['RC4', 'DES', '3DES', 'MD5', 'SHA1'],
            'weak_key_exchange': ['DH-512', 'DH-1024', 'ECDH-P256'],
            'quantum_vulnerable_certs': ['RSA-1024', 'RSA-2048', 'ECDSA-P256', 'ECDSA-P384']
        }

    def ping_sweep(self, network: str, timeout: int = 1) -> List[str]:
        """Perform ping sweep to discover live hosts"""
        if not SCAPY_AVAILABLE:
            return self._ping_sweep_fallback(network, timeout)

        print(f" Performing ping sweep on {network}")
        live_hosts = []

        try:
            # Parse network range
            if '/' in network:
                # CIDR notation
                import ipaddress
                net = ipaddress.IPv4Network(network, strict=False)
                hosts = [str(ip) for ip in net.hosts()]
            elif '-' in network:
                # Range notation (e.g., 192.168.1.1-254)
                base, range_part = network.rsplit('.', 1)
                start, end = map(int, range_part.split('-'))
                hosts = [f"{base}.{i}" for i in range(start, end + 1)]
            else:
                hosts = [network]

            # Limit to reasonable number of hosts
            if len(hosts) > 254:
                hosts = hosts[:254]
                print(f"  Limited scan to first 254 hosts")

            # Send ICMP pings
            for host in hosts:
                try:
                    icmp_packet = IP(dst=host) / ICMP()
                    response = scapy.sr1(icmp_packet, timeout=timeout, verbose=0)

                    if response:
                        live_hosts.append(host)
                        print(f" {host} is alive")
                except Exception as e:
                    # TODO: Consider logging this exception
                    pass

        except Exception as e:
            print(f" Error in ping sweep: {e}")
            return self._ping_sweep_fallback(network, timeout)

        return live_hosts

    def _ping_sweep_fallback(self, network: str, timeout: int = 1) -> List[str]:
        """Fallback ping sweep using system ping command"""
        live_hosts = []

        try:
            if '/' in network:
                import ipaddress
                net = ipaddress.IPv4Network(network, strict=False)
                hosts = [str(ip) for ip in list(net.hosts())[:50]]  # Limit to 50
            elif '-' in network:
                base, range_part = network.rsplit('.', 1)
                start, end = map(int, range_part.split('-'))
                hosts = [f"{base}.{i}" for i in range(start, min(end + 1, start + 50))]
            else:
                hosts = [network]

            for host in hosts:
                try:
                    # Use system ping command
                    result = subprocess.run(['ping', '-c', '1', '-W', str(timeout), host],
                                          capture_output=True, text=True, timeout=timeout + 1)
                    if result.returncode == 0:
                        live_hosts.append(host)
                        print(f" {host} is alive")
                except Exception as e:
                    # TODO: Consider logging this exception
                    pass

        except Exception as e:
            print(f" Error in fallback ping sweep: {e}")

        return live_hosts

    def port_scan(self, host: str, ports: List[int] = None, timeout: int = 3) -> Dict:
        """Scan ports on a host with focus on crypto-relevant services"""
        if ports is None:
            ports = list(self.quantum_relevant_ports.keys())

        print(f" Scanning {len(ports)} ports on {host}")

        results = {
            'host': host,
            'open_ports': [],
            'services': {},
            'crypto_services': [],
            'scan_time': time.time()
        }

        # Use nmap if available for better service detection
        if NMAP_AVAILABLE:
            return self._nmap_scan(host, ports, timeout)

        # Fallback to basic socket scanning
        def scan_port(port):
            """TODO: Add description for scan_port"""
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                result = sock.connect_ex((host, port))
                sock.close()

                if result == 0:
                    service_info = self.quantum_relevant_ports.get(port, {})
                    return {
                        'port': port,
                        'state': 'open',
                        'service': service_info.get('service', 'unknown'),
                        'crypto': service_info.get('crypto', 'unknown')
                    }
            except Exception as e:
                # TODO: Consider logging this exception
                pass
            return None

        # Threaded port scanning
        with ThreadPoolExecutor(max_workers=50) as executor:
            future_to_port = {executor.submit(scan_port, port): port for port in ports}

            for future in as_completed(future_to_port):
                result = future.result()
                if result:
                    results['open_ports'].append(result['port'])
                    results['services'][result['port']] = {
                        'service': result['service'],
                        'crypto': result['crypto']
                    }

                    if result['crypto'] != 'unknown':
                        results['crypto_services'].append(result)

        return results

    def _nmap_scan(self, host: str, ports: List[int], timeout: int) -> Dict:
        """Enhanced port scan using nmap"""
        results = {
            'host': host,
            'open_ports': [],
            'services': {},
            'crypto_services': [],
            'scan_time': time.time()
        }

        try:
            nm = nmap.PortScanner()
            port_range = ','.join(map(str, ports))

            # Perform service version detection scan
            nm.scan(host, port_range, arguments='-sV --version-intensity 5', timeout=timeout)

            if host in nm.all_hosts():
                for port in nm[host]['tcp'].keys():
                    port_info = nm[host]['tcp'][port]

                    if port_info['state'] == 'open':
                        results['open_ports'].append(port)

                        service_name = port_info.get('name', 'unknown')
                        version = port_info.get('version', '')
                        product = port_info.get('product', '')

                        service_info = f"{product} {version}".strip()
                        if not service_info:
                            service_info = service_name

# TODO: Consider breaking this long line (length: 104)
                        crypto_info = self.quantum_relevant_ports.get(port, {}).get('crypto', 'unknown')

                        results['services'][port] = {
                            'service': service_info,
                            'crypto': crypto_info,
                            'raw_info': port_info
                        }

                        if crypto_info != 'unknown':
                            results['crypto_services'].append({
                                'port': port,
                                'service': service_info,
                                'crypto': crypto_info
                            })

        except Exception as e:
            print(f"  Nmap scan failed, falling back to basic scan: {e}")
            return self.port_scan(host, ports, timeout)

        return results

    def ssl_tls_analysis(self, host: str, port: int = 443, timeout: int = 10) -> Dict:
        """Analyze SSL/TLS configuration for quantum vulnerabilities"""
        print(f"[SECURITY] Analyzing SSL/TLS on {host}:{port}")

        analysis = {
            'host': host,
            'port': port,
            'ssl_available': False,
            'protocols': [],
            'ciphers': [],
            'certificate': {},
            'vulnerabilities': [],
            'quantum_readiness': 'UNKNOWN'
        }

        try:
            # Test SSL/TLS connection
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

            with socket.create_connection((host, port), timeout=timeout) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    analysis['ssl_available'] = True

                    # Get certificate information
                    cert = ssock.getpeercert()
                    if cert:
                        analysis['certificate'] = self._analyze_certificate(cert)

                    # Get cipher and protocol information
                    analysis['cipher'] = ssock.cipher()
                    analysis['version'] = ssock.version()

                    # Assess quantum vulnerabilities
                    analysis['vulnerabilities'] = self._assess_ssl_vulnerabilities(analysis)
                    analysis['quantum_readiness'] = self._assess_quantum_readiness(analysis)

        except ssl.SSLError as e:
            analysis['ssl_error'] = str(e)
        except Exception as e:
            analysis['error'] = str(e)

        return analysis

    def _analyze_certificate(self, cert: Dict) -> Dict:
        """Analyze SSL certificate for quantum vulnerabilities"""
        cert_analysis = {
            'subject': cert.get('subject', []),
            'issuer': cert.get('issuer', []),
            'version': cert.get('version', 'unknown'),
            'not_before': cert.get('notBefore', 'unknown'),
            'not_after': cert.get('notAfter', 'unknown'),
            'signature_algorithm': 'unknown',
            'public_key_info': {},
            'quantum_vulnerable': True
        }

        # Extract signature algorithm
        if 'signatureAlgorithm' in cert:
            cert_analysis['signature_algorithm'] = cert['signatureAlgorithm']

        # Analyze public key (simplified - real implementation would be more complex)
        if 'subjectPublicKeyInfo' in cert:
            pki = cert['subjectPublicKeyInfo']
            if 'algorithm' in pki:
                algorithm = pki['algorithm']
                cert_analysis['public_key_info']['algorithm'] = algorithm

                # Determine if quantum vulnerable
                if any(alg in algorithm.lower() for alg in ['rsa', 'ecdsa', 'dsa']):
                    cert_analysis['quantum_vulnerable'] = True
                elif 'ed25519' in algorithm.lower() or 'ed448' in algorithm.lower():
                    cert_analysis['quantum_vulnerable'] = True  # Still quantum vulnerable
                else:
                    cert_analysis['quantum_vulnerable'] = False

        return cert_analysis

    def _assess_ssl_vulnerabilities(self, ssl_info: Dict) -> List[str]:
        """Assess SSL/TLS configuration for vulnerabilities"""
        vulnerabilities = []

        # Check protocol version
        version = ssl_info.get('version', '').lower()
# TODO: Consider breaking this long line (length: 103)
        if any(weak_ver in version for weak_ver in self.vulnerability_indicators['weak_ssl_versions']):
            vulnerabilities.append(f"Weak SSL/TLS version: {version}")

        # Check cipher suite
        cipher_info = ssl_info.get('cipher', ())
        if len(cipher_info) >= 1:
            cipher_name = cipher_info[0]
# TODO: Consider breaking this long line (length: 112)
            if any(weak_cipher in cipher_name for weak_cipher in self.vulnerability_indicators['weak_ciphers']):
                vulnerabilities.append(f"Weak cipher: {cipher_name}")

        # Check certificate
        cert = ssl_info.get('certificate', {})
        if cert.get('quantum_vulnerable', True):
            sig_alg = cert.get('signature_algorithm', 'unknown')
            vulnerabilities.append(f"Quantum-vulnerable certificate signature: {sig_alg}")

        return vulnerabilities

    def _assess_quantum_readiness(self, ssl_info: Dict) -> str:
        """Assess quantum readiness of SSL/TLS configuration"""
        vulnerabilities = ssl_info.get('vulnerabilities', [])

        if not ssl_info.get('ssl_available', False):
            return 'NOT_APPLICABLE'

        # Count quantum-related vulnerabilities
        quantum_vulns = [v for v in vulnerabilities if 'quantum' in v.lower()]
        total_vulns = len(vulnerabilities)

        if len(quantum_vulns) == 0 and total_vulns == 0:
            return 'GOOD'
        elif len(quantum_vulns) <= 1 and total_vulns <= 2:
            return 'FAIR'
        elif len(quantum_vulns) <= 2 and total_vulns <= 4:
            return 'POOR'
        else:
            return 'CRITICAL'

    def discover_quantum_infrastructure(self, networks: List[str]) -> Dict:
        """Comprehensive quantum-focused network discovery"""
        print("[ANALYZE] Starting quantum infrastructure discovery...")

        discovery_results = {
            'networks_scanned': networks,
            'live_hosts': [],
            'quantum_relevant_services': {},
            'ssl_tls_analysis': {},
            'summary': {},
            'recommendations': [],
            'scan_time': time.strftime('%Y-%m-%d %H:%M:%S')
        }

        all_live_hosts = []

        # Host discovery phase
        for network in networks:
            print(f"\n Discovering hosts in {network}")
            live_hosts = self.ping_sweep(network)
            all_live_hosts.extend(live_hosts)
            discovery_results['live_hosts'].extend(live_hosts)

        print(f"\n Found {len(all_live_hosts)} live hosts")

        # Service discovery phase
        print("\n Performing service discovery...")
        for host in all_live_hosts:
            print(f"\n[TARGET] Scanning {host}")

            # Port scan
            scan_results = self.port_scan(host)
            discovery_results['quantum_relevant_services'][host] = scan_results

            # SSL/TLS analysis for HTTPS services
            if 443 in scan_results['open_ports']:
                ssl_analysis = self.ssl_tls_analysis(host, 443)
                discovery_results['ssl_tls_analysis'][f"{host}:443"] = ssl_analysis

            # Check other SSL/TLS services
            ssl_ports = [25, 110, 143, 465, 587, 636, 993, 995, 5061, 8443]
            for port in ssl_ports:
                if port in scan_results['open_ports']:
                    ssl_analysis = self.ssl_tls_analysis(host, port)
                    discovery_results['ssl_tls_analysis'][f"{host}:{port}"] = ssl_analysis

        # Generate summary and recommendations
        discovery_results['summary'] = self._generate_discovery_summary(discovery_results)
        discovery_results['recommendations'] = self._generate_recommendations(discovery_results)

        return discovery_results

    def _generate_discovery_summary(self, results: Dict) -> Dict:
        """Generate summary of discovery results"""
        summary = {
            'total_hosts': len(results['live_hosts']),
            'total_crypto_services': 0,
            'vulnerable_ssl_services': 0,
            'quantum_vulnerable_hosts': 0,
            'service_breakdown': {},
            'vulnerability_breakdown': {}
        }

        # Analyze service data
        for host, scan_data in results['quantum_relevant_services'].items():
            crypto_services = scan_data.get('crypto_services', [])
            summary['total_crypto_services'] += len(crypto_services)

            for service in crypto_services:
                service_name = service.get('service', 'unknown')
                if service_name not in summary['service_breakdown']:
                    summary['service_breakdown'][service_name] = 0
                summary['service_breakdown'][service_name] += 1

        # Analyze SSL/TLS data
        for endpoint, ssl_data in results['ssl_tls_analysis'].items():
            vulnerabilities = ssl_data.get('vulnerabilities', [])

            if vulnerabilities:
                summary['vulnerable_ssl_services'] += 1

                if ssl_data.get('quantum_readiness') in ['POOR', 'CRITICAL']:
                    host = endpoint.split(':')[0]
                    if host not in summary.get('quantum_vulnerable_hosts_list', []):
                        summary['quantum_vulnerable_hosts'] += 1
                        if 'quantum_vulnerable_hosts_list' not in summary:
                            summary['quantum_vulnerable_hosts_list'] = []
                        summary['quantum_vulnerable_hosts_list'].append(host)

                for vuln in vulnerabilities:
                    vuln_type = vuln.split(':')[0] if ':' in vuln else vuln
                    if vuln_type not in summary['vulnerability_breakdown']:
                        summary['vulnerability_breakdown'][vuln_type] = 0
                    summary['vulnerability_breakdown'][vuln_type] += 1

        return summary

    def _generate_recommendations(self, results: Dict) -> List[str]:
        """Generate recommendations based on discovery results"""
        recommendations = []
        summary = results['summary']

        # Host-based recommendations
        if summary['total_hosts'] > 0:
            vuln_ratio = summary['quantum_vulnerable_hosts'] / summary['total_hosts']
            if vuln_ratio > 0.5:
# TODO: Consider breaking this long line (length: 107)
                recommendations.append("HIGH PRIORITY: Over 50% of hosts have quantum-vulnerable services")
            elif vuln_ratio > 0.2:
# TODO: Consider breaking this long line (length: 109)
                recommendations.append("MEDIUM PRIORITY: Over 20% of hosts have quantum-vulnerable services")

        # Service-specific recommendations
        if summary['vulnerable_ssl_services'] > 0:
# TODO: Consider breaking this long line (length: 117)
            recommendations.append(f"Update SSL/TLS configurations on {summary['vulnerable_ssl_services']} services")

        # Vulnerability-specific recommendations
        vuln_breakdown = summary.get('vulnerability_breakdown', {})

        if 'Weak SSL/TLS version' in vuln_breakdown:
# TODO: Consider breaking this long line (length: 109)
            recommendations.append("Disable weak SSL/TLS protocol versions (SSLv2, SSLv3, TLSv1.0, TLSv1.1)")

        if 'Weak cipher' in vuln_breakdown:
# TODO: Consider breaking this long line (length: 101)
            recommendations.append("Update cipher suites to remove weak algorithms (RC4, DES, 3DES)")

        if 'Quantum-vulnerable certificate signature' in vuln_breakdown:
# TODO: Consider breaking this long line (length: 107)
            recommendations.append("Plan migration from RSA/ECDSA certificates to post-quantum signatures")

        # General recommendations
        recommendations.extend([
            "Implement crypto-agility in all systems",
            "Begin planning post-quantum cryptography migration",
            "Regular quantum threat assessments",
            "Monitor NIST post-quantum cryptography standards"
        ])

        return recommendations

    def generate_comprehensive_report(self, networks: List[str]) -> str:
        """Generate comprehensive quantum network reconnaissance report"""
        print(" Starting comprehensive quantum network reconnaissance...")

        # Perform discovery
        results = self.discover_quantum_infrastructure(networks)

        # Generate report
        report = []
        report.append(" Quantum Network Reconnaissance Report")
        report.append("=" * 60)
        report.append(f"[DATE] Scan Date: {results['scan_time']}")
        report.append(f"[TARGET] Networks: {', '.join(networks)}")
        report.append("")

        # Summary
        summary = results['summary']
        report.append(" EXECUTIVE SUMMARY")
        report.append("-" * 30)
        report.append(f"Live hosts discovered: {summary['total_hosts']}")
        report.append(f"Crypto services found: {summary['total_crypto_services']}")
        report.append(f"Vulnerable SSL services: {summary['vulnerable_ssl_services']}")
        report.append(f"Quantum-vulnerable hosts: {summary['quantum_vulnerable_hosts']}")
        report.append("")

        # Service breakdown
        if summary.get('service_breakdown'):
            report.append(" Service Distribution:")
            for service, count in sorted(summary['service_breakdown'].items(),
                                       key=lambda x: x[1], reverse=True):
                report.append(f"   {service}: {count} instances")
            report.append("")

        # Vulnerability breakdown
        if summary.get('vulnerability_breakdown'):
            report.append("  Vulnerability Summary:")
            for vuln_type, count in sorted(summary['vulnerability_breakdown'].items(),
                                          key=lambda x: x[1], reverse=True):
                report.append(f"   {vuln_type}: {count} instances")
            report.append("")

        # Detailed host analysis
        report.append("[TARGET] DETAILED HOST ANALYSIS")
        report.append("-" * 40)

        for host, scan_data in results['quantum_relevant_services'].items():
            report.append(f"  Host: {host}")

            open_ports = scan_data.get('open_ports', [])
            if open_ports:
                report.append(f"   Open ports: {', '.join(map(str, open_ports))}")

                crypto_services = scan_data.get('crypto_services', [])
                if crypto_services:
                    report.append("   [SECURITY] Crypto services:")
                    for service in crypto_services:
                        report.append(f"      Port {service['port']}: {service['service']} "
                                    f"({service['crypto']})")
            else:
                report.append("   No quantum-relevant services detected")

            report.append("")

        # SSL/TLS Analysis
        if results['ssl_tls_analysis']:
            report.append("[SECURITY] SSL/TLS ANALYSIS")
            report.append("-" * 30)

            for endpoint, ssl_data in results['ssl_tls_analysis'].items():
                report.append(f" {endpoint}")

                if ssl_data.get('ssl_available'):
                    report.append(f"   Version: {ssl_data.get('version', 'unknown')}")
# TODO: Consider breaking this long line (length: 106)
                    report.append(f"   Quantum Readiness: {ssl_data.get('quantum_readiness', 'unknown')}")

                    vulnerabilities = ssl_data.get('vulnerabilities', [])
                    if vulnerabilities:
                        report.append("     Vulnerabilities:")
                        for vuln in vulnerabilities:
                            report.append(f"       -  {vuln}")
                    else:
                        report.append("    No vulnerabilities detected")
                else:
                    error = ssl_data.get('error') or ssl_data.get('ssl_error', 'unknown error')
                    report.append(f"    SSL/TLS unavailable: {error}")

                report.append("")

        # Recommendations
        report.append(" RECOMMENDATIONS")
        report.append("-" * 25)

        recommendations = results['recommendations']
        for i, recommendation in enumerate(recommendations, 1):
            report.append(f"{i}. {recommendation}")

        report.append("")

        # Action items
        report.append(" IMMEDIATE ACTION ITEMS")
        report.append("-" * 35)

        if summary['quantum_vulnerable_hosts'] > 0:
            report.append("[ALERT] HIGH PRIORITY:")
# TODO: Consider breaking this long line (length: 115)
            report.append(f"    -  Address quantum vulnerabilities on {summary['quantum_vulnerable_hosts']} hosts")

        if summary['vulnerable_ssl_services'] > 0:
            report.append("  MEDIUM PRIORITY:")
# TODO: Consider breaking this long line (length: 115)
            report.append(f"    -  Update SSL/TLS configurations on {summary['vulnerable_ssl_services']} services")

        report.append(" STRATEGIC PLANNING:")
        report.append("    -  Develop post-quantum cryptography migration roadmap")
        report.append("    -  Implement crypto-agility architecture")
        report.append("    -  Regular quantum threat assessments")

        return "\n".join(report)


def main():
    """Main function for quantum network reconnaissance"""
    parser = argparse.ArgumentParser(
        description='Quantum Network Reconnaissance Tool',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python quantum_network_recon.py 192.168.1.0/24
  python quantum_network_recon.py 10.0.0.1-10.0.0.100
  python quantum_network_recon.py --networks networks.txt
  python quantum_network_recon.py 172.16.0.0/24 --ports 443 22 25 --output report.txt
        """
    )

    parser.add_argument('networks', nargs='*',
                       help='Network ranges to scan (CIDR or range format)')
    parser.add_argument('--networks-file', '-n',
                       help='File containing network ranges (one per line)')
    parser.add_argument('--ports', nargs='+', type=int,
                       help='Specific ports to scan (default: crypto-relevant ports)')
    parser.add_argument('--timeout', type=int, default=3,
                       help='Scan timeout in seconds (default: 3)')
    parser.add_argument('--output', '-o',
                       help='Save report to file')
    parser.add_argument('--host-only',
                       help='Scan single host instead of network discovery')

    args = parser.parse_args()

    # Collect networks
    networks = list(args.networks) if args.networks else []

    if args.networks_file:
        try:
            with open(args.networks_file, 'r') as f:
                file_networks = [line.strip() for line in f if line.strip()]
                networks.extend(file_networks)
        except Exception as e:
            print(f" Error reading networks file: {e}")
            sys.exit(1)

    if not networks and not args.host_only:
        print(" No networks specified")
        parser.print_help()
        sys.exit(1)

    # Initialize reconnaissance tool
    quantum_recon = QuantumNetworkRecon()

    print(" Houdinis - Quantum Network Reconnaissance")
    print("=" * 60)

    if args.host_only:
        print(f"[TARGET] Single host scan: {args.host_only}")
        print()

        # Scan single host
        ports = args.ports if args.ports else list(quantum_recon.quantum_relevant_ports.keys())
        scan_results = quantum_recon.port_scan(args.host_only, ports, args.timeout)

        # SSL analysis if HTTPS detected
        if 443 in scan_results['open_ports']:
            ssl_analysis = quantum_recon.ssl_tls_analysis(args.host_only, 443)

            print(f" Scan Results for {args.host_only}:")
            print(f"Open ports: {scan_results['open_ports']}")
            print(f"Crypto services: {len(scan_results['crypto_services'])}")
            print(f"SSL quantum readiness: {ssl_analysis.get('quantum_readiness', 'N/A')}")

            if ssl_analysis.get('vulnerabilities'):
                print("  SSL vulnerabilities:")
                for vuln in ssl_analysis['vulnerabilities']:
                    print(f"    -  {vuln}")
        else:
            print(f" Scan Results for {args.host_only}:")
            print(f"Open ports: {scan_results['open_ports']}")
            print(f"Crypto services: {len(scan_results['crypto_services'])}")
    else:
        print(f" Networks: {', '.join(networks)}")
        print()

        # Comprehensive network reconnaissance
        report = quantum_recon.generate_comprehensive_report(networks)

        # Display report
        print(report)

        # Save to file if requested
        if args.output:
            try:
                with open(args.output, 'w') as f:
                    f.write(report)
                print(f"\n[SAVE] Report saved to: {args.output}")
            except Exception as e:
                print(f"\n Error saving report: {e}")


if __name__ == "__main__":
    main()
