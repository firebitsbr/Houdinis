#!/usr/bin/env python3
"""
Post-Quantum Migration Tools
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
License: MIT

Tools for assessing and planning migration to post-quantum cryptography
"""

import sys
import os
import re
import json
import argparse
import time
import hashlib
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any

try:
    from qiskit import QuantumCircuit, transpile
    from qiskit.providers.aer import AerSimulator
    import numpy as np
    QISKIT_AVAILABLE = True
except ImportError:
    QISKIT_AVAILABLE = False

try:
    import yaml
    YAML_AVAILABLE = True
except ImportError:
    YAML_AVAILABLE = False


class PostQuantumMigrationTools:
    """Post-Quantum Cryptography Migration Assessment and Planning Tools"""

    def __init__(self):
        """TODO: Add description for __init__"""
        self.quantum_vulnerable_patterns = {
            # RSA patterns
            r'rsa[-_]?\d+': {'algorithm': 'RSA', 'vulnerable': True, 'category': 'signature'},
# TODO: Consider breaking this long line (length: 101)
            r'rsa[-_]?oaep': {'algorithm': 'RSA-OAEP', 'vulnerable': True, 'category': 'encryption'},
            r'rsa[-_]?pss': {'algorithm': 'RSA-PSS', 'vulnerable': True, 'category': 'signature'},
            r'rsa[-_]?pkcs': {'algorithm': 'RSA-PKCS', 'vulnerable': True, 'category': 'signature'},

            # ECDSA/ECDH patterns
            r'ecdsa[-_]?\w*': {'algorithm': 'ECDSA', 'vulnerable': True, 'category': 'signature'},
            r'ecdh[-_]?\w*': {'algorithm': 'ECDH', 'vulnerable': True, 'category': 'key_exchange'},
# TODO: Consider breaking this long line (length: 109)
            r'secp\d+[kr]\d+': {'algorithm': 'ECDSA/ECDH', 'vulnerable': True, 'category': 'elliptic_curve'},
# TODO: Consider breaking this long line (length: 107)
            r'prime\d+v\d+': {'algorithm': 'ECDSA/ECDH', 'vulnerable': True, 'category': 'elliptic_curve'},
            r'ed25519': {'algorithm': 'Ed25519', 'vulnerable': True, 'category': 'signature'},
# TODO: Consider breaking this long line (length: 103)
            r'curve25519': {'algorithm': 'Curve25519', 'vulnerable': True, 'category': 'key_exchange'},

            # DSA patterns
            r'dsa[-_]?\d*': {'algorithm': 'DSA', 'vulnerable': True, 'category': 'signature'},

            # DH patterns
# TODO: Consider breaking this long line (length: 115)
            r'diffie[-_]?hellman': {'algorithm': 'Diffie-Hellman', 'vulnerable': True, 'category': 'key_exchange'},
# TODO: Consider breaking this long line (length: 111)
            r'dh[-_]?group[-_]?\d+': {'algorithm': 'DH-Group', 'vulnerable': True, 'category': 'key_exchange'},
            r'modp[-_]?\d+': {'algorithm': 'MODP', 'vulnerable': True, 'category': 'key_exchange'},

            # Symmetric (Grover-vulnerable)
            r'aes[-_]?128': {'algorithm': 'AES-128', 'vulnerable': True, 'category': 'symmetric'},
            r'3des': {'algorithm': '3DES', 'vulnerable': True, 'category': 'symmetric'},
            r'des': {'algorithm': 'DES', 'vulnerable': True, 'category': 'symmetric'},

            # Hash functions (Grover-vulnerable)
            r'sha[-_]?1': {'algorithm': 'SHA-1', 'vulnerable': True, 'category': 'hash'},
            r'md5': {'algorithm': 'MD5', 'vulnerable': True, 'category': 'hash'},
            r'sha[-_]?224': {'algorithm': 'SHA-224', 'vulnerable': True, 'category': 'hash'},
            r'sha[-_]?256': {'algorithm': 'SHA-256', 'vulnerable': True, 'category': 'hash'}
        }

        self.post_quantum_replacements = {
            'signature': {
                'RSA': ['CRYSTALS-Dilithium', 'FALCON', 'SPHINCS+'],
                'ECDSA': ['CRYSTALS-Dilithium', 'FALCON'],
                'Ed25519': ['CRYSTALS-Dilithium', 'SPHINCS+'],
                'DSA': ['CRYSTALS-Dilithium', 'SPHINCS+']
            },
            'encryption': {
                'RSA-OAEP': ['CRYSTALS-Kyber', 'Classic McEliece', 'NTRU'],
                'ECDH': ['CRYSTALS-Kyber', 'SIKE'],
                'Curve25519': ['CRYSTALS-Kyber']
            },
            'key_exchange': {
                'Diffie-Hellman': ['CRYSTALS-Kyber', 'Classic McEliece'],
                'ECDH': ['CRYSTALS-Kyber', 'SIKE'],
                'DH-Group': ['CRYSTALS-Kyber']
            },
            'symmetric': {
                'AES-128': ['AES-256', 'ChaCha20'],
                '3DES': ['AES-256'],
                'DES': ['AES-256']
            },
            'hash': {
                'SHA-1': ['SHA-3', 'BLAKE3'],
                'MD5': ['SHA-3', 'BLAKE3'],
                'SHA-224': ['SHA-384', 'SHA-3-384'],
                'SHA-256': ['SHA-384', 'SHA-3-384']
            }
        }

        self.nist_approved_algorithms = {
            'signatures': {
                'CRYSTALS-Dilithium': {
                    'status': 'NIST Standard',
                    'security_levels': [2, 3, 5],
                    'key_sizes': ['Dilithium2', 'Dilithium3', 'Dilithium5'],
                    'performance': 'Fast'
                },
                'FALCON': {
                    'status': 'NIST Standard',
                    'security_levels': [1, 5],
                    'key_sizes': ['FALCON-512', 'FALCON-1024'],
                    'performance': 'Compact signatures'
                },
                'SPHINCS+': {
                    'status': 'NIST Standard',
                    'security_levels': [1, 3, 5],
                    'key_sizes': ['SPHINCS+-128s', 'SPHINCS+-192s', 'SPHINCS+-256s'],
                    'performance': 'Stateless, larger signatures'
                }
            },
            'encryption': {
                'CRYSTALS-Kyber': {
                    'status': 'NIST Standard',
                    'security_levels': [1, 3, 5],
                    'key_sizes': ['Kyber-512', 'Kyber-768', 'Kyber-1024'],
                    'performance': 'Fast, small keys'
                },
                'Classic McEliece': {
                    'status': 'NIST Standard',
                    'security_levels': [1, 3, 5],
                    'key_sizes': ['mceliece348864', 'mceliece460896', 'mceliece6960119'],
                    'performance': 'Large keys, conservative security'
                }
            }
        }

    def scan_file_for_crypto(self, file_path: str) -> Dict:
        """Scan a file for cryptographic algorithm usage"""
        results = {
            'file_path': file_path,
            'vulnerable_algorithms': [],
            'total_matches': 0,
            'categories': {},
            'recommendations': []
        }

        try:
            # Determine file type and read appropriately
            if file_path.endswith(('.py', '.java', '.cpp', '.c', '.js', '.ts', '.go', '.rs')):
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read().lower()
            elif file_path.endswith(('.conf', '.config', '.cfg', '.ini')):
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read().lower()
            elif file_path.endswith(('.xml', '.json', '.yaml', '.yml')):
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read().lower()
            else:
                # Try to read as text
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read().lower()

            # Search for vulnerable algorithms
            for pattern, info in self.quantum_vulnerable_patterns.items():
                matches = re.findall(pattern, content, re.IGNORECASE)

                if matches:
                    algorithm_info = {
                        'algorithm': info['algorithm'],
                        'category': info['category'],
                        'matches': len(matches),
                        'pattern': pattern,
                        'examples': list(set(matches))[:5]  # First 5 unique matches
                    }

                    results['vulnerable_algorithms'].append(algorithm_info)
                    results['total_matches'] += len(matches)

                    # Categorize
                    category = info['category']
                    if category not in results['categories']:
                        results['categories'][category] = 0
                    results['categories'][category] += len(matches)

                    # Generate recommendations
# TODO: Consider breaking this long line (length: 110)
                    replacements = self.post_quantum_replacements.get(category, {}).get(info['algorithm'], [])
                    if replacements:
                        results['recommendations'].append({
                            'algorithm': info['algorithm'],
                            'replacements': replacements
                        })

        except Exception as e:
            results['error'] = str(e)

        return results

    def scan_directory(self, directory: str, file_extensions: List[str] = None) -> Dict:
        """Recursively scan directory for cryptographic usage"""
        if file_extensions is None:
            file_extensions = ['.py', '.java', '.cpp', '.c', '.js', '.ts', '.go', '.rs',
                             '.conf', '.config', '.cfg', '.ini', '.xml', '.json', '.yaml', '.yml']

        results = {
            'directory': directory,
            'files_scanned': 0,
            'vulnerable_files': 0,
            'total_vulnerabilities': 0,
            'files': {},
            'summary': {}
        }

        try:
            for root, dirs, files in os.walk(directory):
                for file in files:
                    if any(file.endswith(ext) for ext in file_extensions):
                        file_path = os.path.join(root, file)
                        relative_path = os.path.relpath(file_path, directory)

                        print(f" Scanning: {relative_path}")

                        file_results = self.scan_file_for_crypto(file_path)
                        results['files_scanned'] += 1

                        if file_results['vulnerable_algorithms']:
                            results['vulnerable_files'] += 1
                            results['total_vulnerabilities'] += file_results['total_matches']
                            results['files'][relative_path] = file_results

        except Exception as e:
            results['error'] = str(e)

        # Generate summary
        category_summary = {}
        algorithm_summary = {}

        for file_path, file_data in results['files'].items():
            for vuln in file_data['vulnerable_algorithms']:
                category = vuln['category']
                algorithm = vuln['algorithm']

                if category not in category_summary:
                    category_summary[category] = 0
                category_summary[category] += vuln['matches']

                if algorithm not in algorithm_summary:
                    algorithm_summary[algorithm] = 0
                algorithm_summary[algorithm] += vuln['matches']

        results['summary'] = {
            'by_category': category_summary,
            'by_algorithm': algorithm_summary
        }

        return results

    def generate_migration_plan(self, scan_results: Dict) -> Dict:
        """Generate detailed migration plan based on scan results"""
        plan = {
            'assessment': {
                'total_files': scan_results['files_scanned'],
                'vulnerable_files': scan_results['vulnerable_files'],
                'risk_level': 'LOW'
            },
            'phases': {},
            'recommendations': [],
            'timeline': {},
            'resources': {}
        }

        # Assess risk level
# TODO: Consider breaking this long line (length: 102)
        vulnerability_ratio = scan_results['vulnerable_files'] / max(scan_results['files_scanned'], 1)
        total_vulns = scan_results['total_vulnerabilities']

        if vulnerability_ratio > 0.5 or total_vulns > 100:
            plan['assessment']['risk_level'] = 'HIGH'
        elif vulnerability_ratio > 0.2 or total_vulns > 20:
            plan['assessment']['risk_level'] = 'MEDIUM'

        # Phase 1: Immediate (0-6 months)
        plan['phases']['phase_1'] = {
            'title': 'Assessment and Planning',
            'duration': '0-6 months',
            'priority': 'HIGH',
            'tasks': [
                'Complete cryptographic inventory',
                'Identify critical systems and data flows',
                'Assess quantum threat timeline',
                'Develop migration strategy',
                'Establish crypto-agility principles'
            ]
        }

        # Phase 2: Short-term (6-18 months)
        plan['phases']['phase_2'] = {
            'title': 'Interim Hardening',
            'duration': '6-18 months',
            'priority': 'HIGH',
            'tasks': [
                'Increase key sizes for classical algorithms',
                'Disable weak algorithms (DES, 3DES, MD5, SHA-1)',
                'Implement hybrid classical+post-quantum solutions',
                'Update libraries and frameworks',
                'Begin pilot deployments of PQ algorithms'
            ]
        }

        # Phase 3: Medium-term (18-36 months)
        plan['phases']['phase_3'] = {
            'title': 'Post-Quantum Deployment',
            'duration': '18-36 months',
            'priority': 'MEDIUM',
            'tasks': [
                'Deploy NIST-approved post-quantum algorithms',
                'Migrate critical applications',
                'Update protocols and standards',
                'Train development and operations teams',
                'Establish PQ key management'
            ]
        }

        # Phase 4: Long-term (36+ months)
        plan['phases']['phase_4'] = {
            'title': 'Full Migration and Optimization',
            'duration': '36+ months',
            'priority': 'MEDIUM',
            'tasks': [
                'Complete migration of all systems',
                'Retire all quantum-vulnerable algorithms',
                'Optimize post-quantum implementations',
                'Regular security assessments',
                'Monitor quantum computing developments'
            ]
        }

        # Generate specific recommendations
        summary = scan_results.get('summary', {})

        for category, count in summary.get('by_category', {}).items():
            if category in self.post_quantum_replacements:
                plan['recommendations'].append({
                    'category': category,
                    'finding': f"{count} instances of quantum-vulnerable {category} algorithms",
                    'action': f"Replace with post-quantum {category} algorithms",
                    'priority': 'HIGH' if count > 10 else 'MEDIUM'
                })

        # Timeline
        plan['timeline'] = {
            'start_date': time.strftime('%Y-%m-%d'),
            'phase_1_end': self._add_months(6),
            'phase_2_end': self._add_months(18),
            'phase_3_end': self._add_months(36),
            'full_migration': self._add_months(48)
        }

        # Resource requirements
        plan['resources'] = {
            'personnel': {
                'crypto_specialists': '1-2 FTE',
                'developers': '3-5 FTE',
                'security_architects': '1 FTE',
                'project_managers': '1 FTE'
            },
            'tools': [
                'Post-quantum cryptography libraries',
                'Hybrid crypto implementations',
                'Testing and validation tools',
                'Performance monitoring'
            ],
            'training': [
                'Post-quantum cryptography fundamentals',
                'NIST PQC standards training',
                'Crypto-agility best practices',
                'Implementation security'
            ]
        }

        return plan

    def _add_months(self, months: int) -> str:
        """Add months to current date"""
        import datetime
        current_date = datetime.datetime.now()

        # Simple month addition (approximate)
        year = current_date.year
        month = current_date.month + months

        while month > 12:
            month -= 12
            year += 1

        return f"{year}-{month:02d}-{current_date.day:02d}"

    def simulate_quantum_threat_progression(self) -> Dict:
        """Simulate quantum threat progression over time"""
        if not QISKIT_AVAILABLE:
            return {
                'simulation_available': False,
                'message': 'Qiskit not available for quantum simulation'
            }

        # Simulate quantum computing progress
        years = list(range(2024, 2035))
        threat_levels = []

        for year in years:
            # Simple exponential model for quantum computing progress
            years_from_now = year - 2024

            # Simulate logical qubit count growth
            logical_qubits = 50 * (1.5 ** years_from_now)  # Doubling every ~2 years

            # Calculate threat level based on algorithm requirements
            rsa_2048_threat = logical_qubits / 4000  # ~4000 logical qubits needed for RSA-2048
            ecc_256_threat = logical_qubits / 2000   # ~2000 logical qubits needed for ECC-256

            threat_level = min(max(rsa_2048_threat, ecc_256_threat), 1.0)
            threat_levels.append({
                'year': year,
                'logical_qubits': int(logical_qubits),
                'threat_level': threat_level,
                'rsa_2048_risk': min(rsa_2048_threat, 1.0),
                'ecc_256_risk': min(ecc_256_threat, 1.0)
            })

        return {
            'simulation_available': True,
            'threat_progression': threat_levels,
            'critical_years': {
# TODO: Consider breaking this long line (length: 104)
                'rsa_2048': next((t['year'] for t in threat_levels if t['rsa_2048_risk'] >= 0.5), 2035),
# TODO: Consider breaking this long line (length: 101)
                'ecc_256': next((t['year'] for t in threat_levels if t['ecc_256_risk'] >= 0.5), 2035)
            }
        }

    def generate_comprehensive_report(self, directory: str, output_format: str = 'text') -> str:
        """Generate comprehensive post-quantum migration report"""
        print(" Scanning directory for cryptographic usage...")
        scan_results = self.scan_directory(directory)

        print(" Generating migration plan...")
        migration_plan = self.generate_migration_plan(scan_results)

        print("[ANALYZE] Simulating quantum threat progression...")
        threat_simulation = self.simulate_quantum_threat_progression()

        if output_format == 'json':
            report_data = {
                'scan_results': scan_results,
                'migration_plan': migration_plan,
                'threat_simulation': threat_simulation,
                'generated_at': time.strftime('%Y-%m-%d %H:%M:%S')
            }
            return json.dumps(report_data, indent=2)

        # Text format
        report = []
        report.append(" Post-Quantum Cryptography Migration Assessment")
        report.append("=" * 60)
        report.append(f"[DATE] Assessment Date: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"[DIRECTORY] Directory: {directory}")
        report.append("")

        # Scan results summary
        report.append(" CRYPTOGRAPHIC INVENTORY")
        report.append("-" * 40)
        report.append(f"Files scanned: {scan_results['files_scanned']}")
        report.append(f"Files with crypto: {scan_results['vulnerable_files']}")
        report.append(f"Total vulnerabilities: {scan_results['total_vulnerabilities']}")
        report.append(f"Risk level: {migration_plan['assessment']['risk_level']}")
        report.append("")

        # Algorithm breakdown
        if scan_results.get('summary', {}).get('by_algorithm'):
            report.append(" Algorithm Usage:")
            for alg, count in sorted(scan_results['summary']['by_algorithm'].items(),
                                   key=lambda x: x[1], reverse=True):
                report.append(f"   {alg}: {count} instances")
            report.append("")

        # Category breakdown
        if scan_results.get('summary', {}).get('by_category'):
            report.append(" By Category:")
            for cat, count in scan_results['summary']['by_category'].items():
                report.append(f"   {cat.replace('_', ' ').title()}: {count} instances")
            report.append("")

        # Migration plan
        report.append("[ROADMAP]  MIGRATION PLAN")
        report.append("-" * 40)

        for phase_key, phase_info in migration_plan['phases'].items():
            report.append(f" {phase_info['title']} ({phase_info['duration']})")
            report.append(f"   Priority: {phase_info['priority']}")
            for task in phase_info['tasks']:
                report.append(f"    -  {task}")
            report.append("")

        # Timeline
        timeline = migration_plan['timeline']
        report.append("[DATE] TIMELINE")
        report.append("-" * 20)
        report.append(f"Start: {timeline['start_date']}")
        report.append(f"Phase 1 Complete: {timeline['phase_1_end']}")
        report.append(f"Phase 2 Complete: {timeline['phase_2_end']}")
        report.append(f"Phase 3 Complete: {timeline['phase_3_end']}")
        report.append(f"Full Migration: {timeline['full_migration']}")
        report.append("")

        # Threat simulation
        if threat_simulation['simulation_available']:
            report.append("[ANALYZE] QUANTUM THREAT SIMULATION")
            report.append("-" * 40)

            critical_years = threat_simulation['critical_years']
            report.append(f"RSA-2048 at risk: ~{critical_years['rsa_2048']}")
            report.append(f"ECC-256 at risk: ~{critical_years['ecc_256']}")
            report.append("")

            report.append("[STATS] Threat Progression (selected years):")
            progression = threat_simulation['threat_progression']
            for i in range(0, len(progression), 2):  # Every other year
                year_data = progression[i]
# TODO: Consider breaking this long line (length: 102)
                report.append(f"   {year_data['year']}: {year_data['threat_level']:.1%} threat level "
                            f"({year_data['logical_qubits']} logical qubits)")
            report.append("")

        # Recommendations
        report.append(" PRIORITY RECOMMENDATIONS")
        report.append("-" * 40)

        recommendations = migration_plan['recommendations']
        for i, rec in enumerate(recommendations[:5], 1):  # Top 5
            report.append(f"{i}. {rec['action']}")
            report.append(f"   Finding: {rec['finding']}")
            report.append(f"   Priority: {rec['priority']}")
            report.append("")

        # NIST approved algorithms
        report.append("[STRUCTURE]  NIST-APPROVED POST-QUANTUM ALGORITHMS")
        report.append("-" * 50)

        for category, algorithms in self.nist_approved_algorithms.items():
            report.append(f" {category.title()}:")
            for alg_name, alg_info in algorithms.items():
                report.append(f"   [ITEM] {alg_name}")
                report.append(f"      Status: {alg_info['status']}")
                report.append(f"      Security Levels: {alg_info['security_levels']}")
                report.append(f"      Performance: {alg_info['performance']}")
            report.append("")

        # Most vulnerable files
        if scan_results['files']:
            report.append("  MOST VULNERABLE FILES")
            report.append("-" * 30)

            # Sort files by vulnerability count
            sorted_files = sorted(scan_results['files'].items(),
                                key=lambda x: x[1]['total_matches'], reverse=True)

            for file_path, file_data in sorted_files[:10]:  # Top 10
                report.append(f"[FILE] {file_path}")
                report.append(f"   Vulnerabilities: {file_data['total_matches']}")

                # Show top algorithms
                top_algs = sorted(file_data['vulnerable_algorithms'],
                                key=lambda x: x['matches'], reverse=True)[:3]
                for alg in top_algs:
                    report.append(f"    -  {alg['algorithm']}: {alg['matches']} instances")
                report.append("")

        return "\n".join(report)


def main():
    """Main function for post-quantum migration tools"""
    parser = argparse.ArgumentParser(
        description='Post-Quantum Cryptography Migration Assessment Tools',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python pq_migration_tools.py /path/to/project
  python pq_migration_tools.py . --output migration_plan.txt
  python pq_migration_tools.py /src --format json --output report.json
  python pq_migration_tools.py /app --extensions .py .java .cpp
        """
    )

    parser.add_argument('directory',
                       help='Directory to scan for cryptographic usage')
    parser.add_argument('--extensions', nargs='+',
                       help='File extensions to scan (default: common code/config files)')
    parser.add_argument('--output', '-o',
                       help='Save report to file')
    parser.add_argument('--format', choices=['text', 'json'], default='text',
                       help='Output format (default: text)')
    parser.add_argument('--file-only',
                       help='Scan single file instead of directory')

    args = parser.parse_args()

    # Initialize migration tools
    pq_tools = PostQuantumMigrationTools()

    print(" Houdinis - Post-Quantum Migration Tools")
    print("=" * 60)

    if args.file_only:
        print(f"[FILE] Scanning file: {args.file_only}")
        print()

        # Scan single file
        result = pq_tools.scan_file_for_crypto(args.file_only)

        if args.format == 'json':
            output = json.dumps(result, indent=2)
        else:
            output = f"File: {result['file_path']}\n"
            output += f"Vulnerabilities: {len(result['vulnerable_algorithms'])}\n"
            output += f"Total matches: {result['total_matches']}\n\n"

            for vuln in result['vulnerable_algorithms']:
                output += f"Algorithm: {vuln['algorithm']}\n"
                output += f"Category: {vuln['category']}\n"
                output += f"Matches: {vuln['matches']}\n"
                output += f"Examples: {', '.join(vuln['examples'])}\n\n"
    else:
        print(f"[DIRECTORY] Scanning directory: {args.directory}")
        print()

        # Comprehensive assessment
        output = pq_tools.generate_comprehensive_report(args.directory, args.format)

    # Display results
    print(output)

    # Save to file if requested
    if args.output:
        try:
            with open(args.output, 'w') as f:
                f.write(output)
            print(f"\n[SAVE] Report saved to: {args.output}")
        except Exception as e:
            print(f"\n Error saving report: {e}")


if __name__ == "__main__":
    main()
