#!/usr/bin/env python3
"""
Houdinis Framework - SSH Quantum Attack Module
Author: Mauro Risonho de Paula Assumpção aka firebitsbr
License: MIT

Analyzes SSH key exchange and RSA host keys for quantum vulnerabilities
"""

import sys
import socket
import struct
import hashlib
import base64
import argparse
from pathlib import Path

try:
    from qiskit import QuantumCircuit, transpile, ClassicalRegister, QuantumRegister
    from qiskit.providers.aer import AerSimulator
    QISKIT_AVAILABLE = True
except ImportError:
    QISKIT_AVAILABLE = False

try:
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import rsa, dsa
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False


class SSHQuantumAttack:
    """SSH Quantum Vulnerability Assessment"""
    
    def __init__(self):
        self.vulnerable_algorithms = {
            'ssh-rsa': {'quantum_vulnerable': True, 'replacement': 'ssh-ed25519'},
            'ssh-dss': {'quantum_vulnerable': True, 'replacement': 'ssh-ed25519'}, 
            'ecdsa-sha2-nistp256': {'quantum_vulnerable': True, 'replacement': 'ssh-ed25519'},
            'ecdsa-sha2-nistp384': {'quantum_vulnerable': True, 'replacement': 'ssh-ed25519'},
            'ecdsa-sha2-nistp521': {'quantum_vulnerable': True, 'replacement': 'ssh-ed25519'},
            'ssh-ed25519': {'quantum_vulnerable': False, 'replacement': None},
            'ssh-ed448': {'quantum_vulnerable': False, 'replacement': None}
        }
    
    def parse_ssh_packet(self, data: bytes) -> dict:
        """Parse SSH identification and key exchange packets"""
        result = {}
        
        if data.startswith(b'SSH-'):
            # Parse SSH identification string
            identification = data.split(b'\r\n')[0].decode('utf-8', errors='ignore')
            result['identification'] = identification
            result['version'] = identification.split('-')[1] if '-' in identification else 'unknown'
            result['software'] = identification.split('-')[2] if identification.count('-') >= 2 else 'unknown'
        
        return result
    
    def extract_host_key_info(self, host: str, port: int = 22) -> dict:
        """Extract SSH host key information for quantum analysis"""
        # Input validation
        import re
        if not re.match(r'^[a-zA-Z0-9.-]+$', host):
            return {'error': 'Invalid hostname format'}
        
        if not (1 <= port <= 65535):
            return {'error': 'Invalid port number'}
            
        print(f" Analyzing SSH server: {host}:{port}")
        
        try:
            # Connect to SSH server with proper timeout and error handling
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            
            # Validate connection attempt
            sock.connect((host, port))
            
            # Read SSH identification with size limit
            identification = sock.recv(1024)
            if len(identification) > 1024:
                sock.close()
                return {'error': 'Response too large'}
                
            ssh_info = self.parse_ssh_packet(identification)
            
            # Send our identification (secure version)
            client_id = b"SSH-2.0-Houdini_SSH_Scanner_1.0\r\n"
            sock.send(client_id)
            
            # Simplified key exchange initiation
            kexinit = self._create_kexinit_packet()
            sock.send(kexinit)
            
            # Read server's KEXINIT
            response = sock.recv(4096)
            server_kex = self._parse_kexinit(response)
            
            sock.close()
            
            result = {
                'host': host,
                'port': port,
                'ssh_version': ssh_info.get('version', 'unknown'),
                'software': ssh_info.get('software', 'unknown'),
                'supported_kex': server_kex.get('kex_algorithms', []),
                'supported_host_keys': server_kex.get('host_key_algorithms', []),
                'supported_ciphers': server_kex.get('encryption_algorithms', []),
                'supported_macs': server_kex.get('mac_algorithms', [])
            }
            
            return result
            
        except Exception as e:
            print(f" Error connecting to {host}:{port}: {e}")
            return {'host': host, 'port': port, 'error': str(e)}
    
    def _create_kexinit_packet(self) -> bytes:
        """Create a basic SSH KEXINIT packet"""
        # Simplified KEXINIT packet for demonstration
        packet_data = bytearray()
        
        # SSH packet header (length will be calculated)
        packet_data.extend(b'\x00\x00\x00\x00')  # Length placeholder
        
        # Padding length (1 byte)
        packet_data.extend(b'\x08')
        
        # Message type (SSH_MSG_KEXINIT = 20)
        packet_data.extend(b'\x14')
        
        # Random bytes (16 bytes)
        packet_data.extend(b'\x00' * 16)
        
        # Algorithm lists (simplified)
        algorithms = [
            "diffie-hellman-group14-sha256,diffie-hellman-group16-sha512",  # KEX
            "ssh-rsa,ssh-ed25519",  # Host key
            "aes128-ctr,aes256-ctr",  # Encryption client to server
            "aes128-ctr,aes256-ctr",  # Encryption server to client  
            "hmac-sha2-256,hmac-sha2-512",  # MAC client to server
            "hmac-sha2-256,hmac-sha2-512",  # MAC server to client
            "none",  # Compression client to server
            "none",  # Compression server to client
            "",  # Languages client to server
            ""   # Languages server to client
        ]
        
        for alg_list in algorithms:
            alg_bytes = alg_list.encode('utf-8')
            packet_data.extend(struct.pack('>I', len(alg_bytes)))
            packet_data.extend(alg_bytes)
        
        # First KEX packet follows (1 byte)
        packet_data.extend(b'\x00')
        
        # Reserved (4 bytes)
        packet_data.extend(b'\x00\x00\x00\x00')
        
        # Add padding
        packet_data.extend(b'\x00' * 8)
        
        # Set correct packet length
        packet_length = len(packet_data) - 4
        struct.pack_into('>I', packet_data, 0, packet_length)
        
        return bytes(packet_data)
    
    def _parse_kexinit(self, data: bytes) -> dict:
        """Parse SSH KEXINIT response (simplified)"""
        result = {}
        
        if len(data) < 6:
            return result
        
        try:
            # Skip packet length and padding length
            offset = 6
            
            # Skip message type and random bytes  
            if data[offset:offset+1] == b'\x14':  # SSH_MSG_KEXINIT
                offset += 17  # Skip message type + 16 random bytes
                
                # Parse algorithm name lists
                alg_names = [
                    'kex_algorithms', 'host_key_algorithms', 
                    'encryption_algorithms_ctos', 'encryption_algorithms_stoc',
                    'mac_algorithms_ctos', 'mac_algorithms_stoc',
                    'compression_algorithms_ctos', 'compression_algorithms_stoc',
                    'languages_ctos', 'languages_stoc'
                ]
                
                for name in alg_names:
                    if offset + 4 <= len(data):
                        length = struct.unpack('>I', data[offset:offset+4])[0]
                        offset += 4
                        
                        if offset + length <= len(data):
                            alg_list = data[offset:offset+length].decode('utf-8', errors='ignore')
                            result[name] = alg_list.split(',')
                            offset += length
                        else:
                            break
                    else:
                        break
        
        except Exception as e:
            print(f"  Error parsing KEXINIT: {e}")
        
        return result
    
    def assess_quantum_vulnerability(self, ssh_info: dict) -> dict:
        """Assess quantum vulnerability of SSH configuration"""
        if 'error' in ssh_info:
            return {'vulnerable': True, 'reason': 'Connection failed', 'recommendations': []}
        
        vulnerabilities = []
        recommendations = []
        risk_score = 0
        
        # Check host key algorithms
        host_keys = ssh_info.get('supported_host_keys', [])
        for algorithm in host_keys:
            if algorithm in self.vulnerable_algorithms:
                vuln_info = self.vulnerable_algorithms[algorithm]
                if vuln_info['quantum_vulnerable']:
                    vulnerabilities.append(f"Quantum-vulnerable host key: {algorithm}")
                    if vuln_info['replacement']:
                        recommendations.append(f"Replace {algorithm} with {vuln_info['replacement']}")
                    risk_score += 3
        
        # Check key exchange algorithms
        kex_algorithms = ssh_info.get('supported_kex', [])
        quantum_vulnerable_kex = [
            'diffie-hellman-group1-sha1', 'diffie-hellman-group14-sha1',
            'ecdh-sha2-nistp256', 'ecdh-sha2-nistp384', 'ecdh-sha2-nistp521'
        ]
        
        for algorithm in kex_algorithms:
            if any(vuln in algorithm for vuln in quantum_vulnerable_kex):
                vulnerabilities.append(f"Quantum-vulnerable key exchange: {algorithm}")
                recommendations.append(f"Use post-quantum key exchange algorithms")
                risk_score += 2
        
        # Check SSH version
        ssh_version = ssh_info.get('ssh_version', '')
        if ssh_version.startswith('1.'):
            vulnerabilities.append("SSH version 1.x is completely insecure")
            recommendations.append("Upgrade to SSH version 2.0 or higher")
            risk_score += 5
        
        # Determine overall risk level
        if risk_score >= 8:
            risk_level = "CRITICAL"
        elif risk_score >= 5:
            risk_level = "HIGH" 
        elif risk_score >= 2:
            risk_level = "MEDIUM"
        elif risk_score > 0:
            risk_level = "LOW"
        else:
            risk_level = "MINIMAL"
        
        return {
            'vulnerable': len(vulnerabilities) > 0,
            'risk_level': risk_level,
            'risk_score': risk_score,
            'vulnerabilities': vulnerabilities,
            'recommendations': recommendations,
            'quantum_ready': risk_score == 0
        }
    
    def simulate_shor_rsa_attack(self, key_size: int) -> dict:
        """Simulate Shor's algorithm attack on RSA key"""
        if not QISKIT_AVAILABLE:
            return {
                'success': False,
                'method': 'classical_simulation',
                'message': 'Qiskit not available - using classical estimation',
                'estimated_time': f"2^{key_size//2} operations"
            }
        
        print(f"[ANALYZE] Simulating Shor's algorithm on {key_size}-bit RSA key")
        
        # Create quantum circuit for Shor's algorithm simulation
        n_qubits = max(key_size * 2, 8)  # Oversimplified for demonstration
        qc = QuantumCircuit(n_qubits, n_qubits)
        
        # Simplified Shor's algorithm steps
        # 1. Initialize superposition
        for i in range(n_qubits // 2):
            qc.h(i)
        
        # 2. Quantum modular exponentiation (simplified)
        for i in range(n_qubits // 2):
            qc.cx(i, n_qubits // 2 + i)
        
        # 3. Quantum Fourier Transform (simplified)
        for i in range(n_qubits // 2):
            qc.h(i)
            for j in range(i):
                qc.cp(3.14159 / (2**(i-j)), j, i)
        
        # 4. Measurement
        qc.measure_all()
        
        # Simulate the circuit
        simulator = AerSimulator()
        transpiled_qc = transpile(qc, simulator)
        job = simulator.run(transpiled_qc, shots=1024)
        result = job.result()
        counts = result.get_counts()
        
        # Analyze results
        most_common = max(counts.items(), key=lambda x: x[1])
        success_probability = most_common[1] / 1024
        
        # Calculate theoretical time requirements
        classical_time = 2 ** (key_size // 3)  # Simplified
        quantum_time = key_size ** 3  # Polynomial time for quantum
        
        return {
            'success': True,
            'method': 'quantum_simulation',
            'key_size': key_size,
            'qubits_required': n_qubits,
            'success_probability': success_probability,
            'classical_time_estimate': classical_time,
            'quantum_time_estimate': quantum_time,
            'quantum_advantage': classical_time / quantum_time,
            'measurement_results': dict(list(counts.items())[:5])  # Top 5 results
        }
    
    def generate_report(self, target_hosts: list) -> str:
        """Generate comprehensive SSH quantum vulnerability report"""
        report = []
        report.append(" SSH Quantum Vulnerability Assessment Report")
        report.append("=" * 60)
        report.append(f"[DATE] Assessed {len(target_hosts)} target(s)")
        report.append("")
        
        total_vulnerable = 0
        critical_hosts = []
        
        for i, host in enumerate(target_hosts, 1):
            if ':' in host:
                hostname, port = host.split(':')
                port = int(port)
            else:
                hostname, port = host, 22
            
            report.append(f"[TARGET] Target {i}: {hostname}:{port}")
            report.append("-" * 40)
            
            # Get SSH information
            ssh_info = self.extract_host_key_info(hostname, port)
            
            if 'error' in ssh_info:
                report.append(f" Connection failed: {ssh_info['error']}")
                report.append("")
                continue
            
            # Assess vulnerability
            assessment = self.assess_quantum_vulnerability(ssh_info)
            
            if assessment['vulnerable']:
                total_vulnerable += 1
                if assessment['risk_level'] in ['CRITICAL', 'HIGH']:
                    critical_hosts.append(f"{hostname}:{port}")
            
            # Add details to report
            report.append(f" SSH Version: {ssh_info.get('ssh_version', 'unknown')}")
            report.append(f" Software: {ssh_info.get('software', 'unknown')}")
            report.append(f"  Risk Level: {assessment['risk_level']}")
            report.append(f" Risk Score: {assessment['risk_score']}/10")
            report.append(f" Quantum Ready: {'Yes' if assessment['quantum_ready'] else 'No'}")
            
            if assessment['vulnerabilities']:
                report.append("  Vulnerabilities:")
                for vuln in assessment['vulnerabilities']:
                    report.append(f"    -  {vuln}")
            
            if assessment['recommendations']:
                report.append(" Recommendations:")
                for rec in assessment['recommendations']:
                    report.append(f"    -  {rec}")
            
            # Host key analysis
            host_keys = ssh_info.get('supported_host_keys', [])
            if host_keys:
                report.append(" Host Key Algorithms:")
                for key_alg in host_keys:
                    quantum_vuln = "[CRITICAL]" if key_alg in self.vulnerable_algorithms and \
                                  self.vulnerable_algorithms[key_alg]['quantum_vulnerable'] else "🟢"
                    report.append(f"   {quantum_vuln} {key_alg}")
            
            report.append("")
        
        # Summary
        report.append(" SUMMARY")
        report.append("=" * 30)
        report.append(f"Total hosts scanned: {len(target_hosts)}")
        report.append(f"Vulnerable hosts: {total_vulnerable}")
        report.append(f"Critical/High risk: {len(critical_hosts)}")
        
        if critical_hosts:
            report.append(f"  Priority targets: {', '.join(critical_hosts)}")
        
        # Shor's algorithm demonstration
        report.append("")
        report.append("[ANALYZE] RSA Quantum Attack Simulation")
        report.append("-" * 40)
        shor_result = self.simulate_shor_rsa_attack(1024)
        
        if shor_result['success']:
            report.append(f"[TARGET] Target: 1024-bit RSA key")
            report.append(f" Method: {shor_result['method']}")
            report.append(f"[ELECTRIC] Qubits required: {shor_result['qubits_required']}")
            report.append(f"[STATS] Success probability: {shor_result['success_probability']:.3f}")
            if 'quantum_advantage' in shor_result:
                report.append(f" Quantum advantage: {shor_result['quantum_advantage']:.2e}x faster")
        else:
            report.append(f"  Simulation unavailable: {shor_result['message']}")
        
        return "\n".join(report)


def main():
    """Main function for SSH quantum attack module"""
    parser = argparse.ArgumentParser(
        description='SSH Quantum Vulnerability Assessment',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python ssh_quantum_attack.py example.com
  python ssh_quantum_attack.py 192.168.1.1:2222
  python ssh_quantum_attack.py host1.com host2.com:2222 host3.com
        """
    )
    
    parser.add_argument('targets', nargs='+', 
                       help='Target hosts (format: host or host:port)')
    parser.add_argument('--output', '-o', 
                       help='Save report to file')
    parser.add_argument('--timeout', type=int, default=10,
                       help='Connection timeout in seconds (default: 10)')
    
    args = parser.parse_args()
    
    if not args.targets:
        print(" No target hosts specified")
        parser.print_help()
        sys.exit(1)
    
    # Initialize attack module
    ssh_attack = SSHQuantumAttack()
    
    print(" Houdinis - SSH Quantum Vulnerability Scanner")
    print("=" * 60)
    print(f"[TARGET] Targets: {', '.join(args.targets)}")
    print()
    
    # Generate report
    report = ssh_attack.generate_report(args.targets)
    
    # Display report
    print(report)
    
    # Save to file if requested
    if args.output:
        try:
            with open(args.output, 'w') as f:
                f.write(report)
            print(f"\n[SAVE] Report saved to: {args.output}")
        except Exception as e:
            print(f"\n Error saving report: {e}")


if __name__ == "__main__":
    main()
